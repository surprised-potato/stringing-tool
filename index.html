<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar Array Layout & Stringing</title>
    <style>
        * { box-sizing: border-box; }
        html, body {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background-color: #f0f2f5;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* --- Layout Structures --- */
        .sidebar { position: fixed; left: 0; top: 0; bottom: 0; width: 60px; background: #fff; border-right: 1px solid #ddd; z-index: 200; display: flex; flex-direction: column; align-items: center; padding-top: 15px; box-shadow: 2px 0 5px rgba(0,0,0,0.05); }
        .sidebar-btn { width: 40px; height: 40px; margin-bottom: 15px; border: 1px solid #eee; border-radius: 8px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 18px; color: #555; background: #f9f9f9; transition: all 0.2s; }
        .sidebar-btn:hover { background: #f0f0f0; border-color: #ccc; }
        .sidebar-btn.active { background: #3b82f6; color: white; border-color: #2563eb; box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3); }
        
        .panel-drawer { position: fixed; left: 60px; top: 0; bottom: 0; width: 320px; background: #fff; border-right: 1px solid #ddd; z-index: 150; transform: translateX(-100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); display: flex; flex-direction: column; }
        .panel-drawer.open { transform: translateX(0); box-shadow: 4px 0 10px rgba(0,0,0,0.05); }
        
        .panel-content { padding: 15px; overflow-y: auto; overflow-x: hidden; flex: 1; display: none; flex-direction: column; }
        .panel-content.active { display: flex; }
        
        .panel-header { padding: 15px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; }
        .panel-header h2 { margin: 0; font-size: 16px; color: #333; }
        
        #canvas-container { position: absolute; top: 0; left: 0; right: 0; bottom: 0; z-index: 1; background-color: #e5e5e5; background-image: linear-gradient(#ddd 1px, transparent 1px), linear-gradient(90deg, #ddd 1px, transparent 1px); background-size: 20px 20px; cursor: grab; }
        #canvas-container:active { cursor: grabbing; }
        
        canvas { display: block; }

        /* --- Floating Elements --- */
        .top-actions { position: fixed; top: 15px; right: 15px; z-index: 300; display: flex; gap: 8px; }
        .stats-bar { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(255,255,255,0.95); padding: 8px 20px; border-radius: 20px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 300; font-size: 13px; color: #333; pointer-events: none; border: 1px solid #ddd; }
        .zoom-controls { position: absolute; bottom: 20px; right: 20px; display: flex; flex-direction: column; gap: 5px; z-index: 100; }
        .zoom-btn { width: 32px; height: 32px; border: 1px solid #ccc; background: #fff; cursor: pointer; font-size: 16px; border-radius: 4px; }
        
       /* --- Component Styles --- */
        .input-group { display: flex; flex-direction: column; margin-bottom: 10px; min-width: 0; }
        .input-group label { font-size: 11px; font-weight: bold; color: #666; margin-bottom: 4px; }
        .input-group input, .input-group select { padding: 6px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px; width: 100%; }

        .array-list { display: flex; flex-direction: column; gap: 4px; margin: 10px 0; border: 1px solid #eee; background: #fafafa; padding: 5px; border-radius: 4px; max-height: 400px; overflow-y: auto; }
        .array-item { padding: 8px 10px; border: 1px solid #ddd; background: #fff; border-radius: 4px; cursor: pointer; font-size: 12px; display: flex; justify-content: space-between; align-items: center; }
        .array-item:hover { background: #f9f9f9; border-color: #bbb; }
        .array-item.selected { background: #eff6ff; border-color: #3b82f6; color: #1e40af; font-weight: bold; }
        .array-group-tag { font-size: 10px; background: #e5e7eb; color: #555; padding: 2px 5px; border-radius: 3px; margin-right: 5px; }

        .props-panel { background: #f9f9f9; border: 1px solid #ddd; padding: 12px; border-radius: 6px; font-size: 12px; margin-top: 10px; }
        .props-row { display: flex; gap: 8px; align-items: center; margin-bottom: 10px; flex-wrap: wrap; }
        .validation-msg { color: #d97706; font-size: 11px; margin-top: 4px; font-style: italic; }
        
        .string-row { display: flex; gap: 10px; margin-bottom: 8px; align-items: center; background: #fff; padding: 5px; border: 1px solid #eee; border-radius: 4px; }

        .btn { padding: 6px 12px; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; color: white; transition: background 0.2s; }
        .btn:hover { opacity: 0.9; }
        .btn-add { background-color: #10b981; }
        
        .tool-group { background:#fff; border:1px solid #ccc; border-radius:4px; display:flex; margin-right:10px; overflow:hidden; }
        .btn-tool { border:none; background:none; padding:6px 12px; cursor:pointer; font-size:16px; color:#555; transition:background 0.1s; }
        .btn-tool:hover { background: #f0f0f0; }
        .btn-tool.active { background-color: #e0f2fe; color: #0284c7; box-shadow:inset 0 2px 4px rgba(0,0,0,0.05); }
        .btn-tool + .btn-tool { border-left:1px solid #eee; }
        .btn-danger { background-color: #ef4444; }
        .btn-blue { background-color: #3b82f6; }
        .btn-gray { background-color: #6b7280; }

        .tooltip { position: absolute; background: rgba(0, 0, 0, 0.8); color: white; padding: 5px 10px; border-radius: 4px; pointer-events: none; font-size: 12px; display: none; z-index: 1000; }
        #file_loader { display: none; }

        .print-list { max-height: 300px; overflow-y: auto; border: 1px solid #eee; padding: 10px; margin-bottom: 15px; border-radius: 4px; background: #f9f9f9; }
        .print-group-header { font-weight: bold; color: #555; margin-top: 10px; padding-bottom: 5px; border-bottom: 1px solid #eee; font-size: 13px; }
        .print-group-header:first-child { margin-top: 0; }
        .print-item { display: flex; align-items: center; padding: 8px 5px; border-bottom: 1px solid #fff; font-size: 13px; }
        .print-item:hover { background: #fff; }
        .print-item input { margin-right: 10px; cursor: pointer; }
        .print-item label { cursor: pointer; flex: 1; user-select: none; }

        /* Modal */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 2000; display: none; align-items: center; justify-content: center; }
        .modal-content { background: white; padding: 20px; border-radius: 8px; width: 600px; max-width: 90%; max-height: 80vh; overflow-y: auto; display: flex; flex-direction: column; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; border-bottom: 1px solid #eee; padding-bottom: 10px; }
        .close-modal { background: none; border: none; font-size: 24px; cursor: pointer; color: #666; line-height: 1; }
    </style>
</head>
<body>
    <div class="sidebar">
        <div class="sidebar-btn" id="btn_layout" onclick="togglePanel('layout')" title="Layout & Arrays">‚äû</div>
        <div class="sidebar-btn" id="btn_electrical" onclick="togglePanel('electrical')" title="Strings & Inverters">‚ö°</div>
        <div class="sidebar-btn" id="btn_algo" onclick="togglePanel('algo')" title="Fill Algorithm">‚öô</div>
        <div class="sidebar-btn" id="btn_materials" onclick="togglePanel('materials')" title="Materials">üõ†</div>
        <div class="sidebar-btn" id="btn_filters" onclick="togglePanel('filters')" title="Visibility Filters">üëÅ</div>
    </div>

    <div class="panel-drawer" id="main_drawer">
        
        <div id="panel_layout" class="panel-content">
            <div class="panel-header">
                <h2>Layout Configuration</h2>
                <button class="btn btn-add" onclick="addNewArray()">+ Add</button>
            </div>
            
            <div id="array_list" class="array-list"></div>

            <div id="props_panel" class="props-panel" style="display:none;">
                <div id="props_active" style="display:none;">
                    <div class="props-row">
                        <div class="input-group" style="flex:1">
                            <label>Name</label>
                            <input type="text" id="prop_name" style="width:100%" onchange="updateSelectedProp('name', this.value)">
                        </div>
                        <div class="input-group" style="width:80px">
                            <label>Group</label>
                            <input type="text" id="prop_group" style="width:100%" list="group_suggestions" onchange="updateSelectedProp('group', this.value)">
                            <datalist id="group_suggestions"><option value="South Roof"><option value="West Garage"></datalist>
                        </div>
                        <button class="btn btn-danger" onclick="removeSelectedArray()" style="margin-top:14px">Del</button>
                    </div>
                    <hr style="border:0; border-top:1px solid #eee; margin:10px 0;">
                    <div class="props-row">
                        <div class="input-group" style="flex:1">
                            <label>Shape</label>
                            <select id="prop_shape" onchange="updateSelectedProp('type', this.value)">
                                <option value="rect">Rectangle</option>
                                <option value="trap">Trapezoid</option>
                            </select>
                        </div>
                        <div class="input-group" style="width:80px">
                             <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
                                <label style="margin:0;">Rot(¬∞)</label>
                                <input type="checkbox" id="chk_manual_rot" title="Manual Rotation" style="width:auto; margin:0;" onchange="updateSelectedProp('manualRot', this.checked)">
                            </div>
                            <input type="number" id="prop_rot" value="0" step="5" onchange="updateSelectedProp('rot', this.value)">
                        </div>
                    </div>
                    <div class="props-row">
                        <div class="input-group" style="flex:1">
                        <label>Rail Dir</label>
                        <select id="prop_rail_dir" onchange="updateSelectedProp('railDir', this.value)">
                            <option value="row">Horizontal</option>
                            <option value="col">Vertical</option>
                        </select>
                    </div>
                    <div class="input-group" style="flex:1">
                        <label>Slope</label>
                        <select id="prop_slope_dir" onchange="updateSelectedProp('slopeDir', this.value)">
                            <option value="S">South (S)</option>
                            <option value="SE">South East (SE)</option>
                            <option value="E">East (E)</option>
                            <option value="NE">North East (NE)</option>
                            <option value="N">North (N)</option>
                            <option value="NW">North West (NW)</option>
                            <option value="W">West (W)</option>
                            <option value="SW">South West (SW)</option>
                        </select>
                    </div>
                </div>
                <div id="shape_rect_inputs" style="display:none;">
                    <div class="props-row">
                        <div class="input-group"><label>Rows</label><input type="number" id="prop_r_rows" onchange="updateSelectedProp('rows', this.value)"></div>
                        <div class="input-group"><label>Cols</label><input type="number" id="prop_r_cols" onchange="updateSelectedProp('cols', this.value)"></div>
                    </div>
                </div>
                    <div id="shape_trap_inputs" style="display:none;">
                        <div class="props-row">
                            <div class="input-group"><label>Top</label><input type="number" id="prop_t_top" onchange="updateSelectedProp('top', this.value)"></div>
                            <div class="input-group"><label>Btm</label><input type="number" id="prop_t_bottom" onchange="updateSelectedProp('bottom', this.value)"></div>
                            <div class="input-group"><label>Hgt</label><input type="number" id="prop_t_height" onchange="updateSelectedProp('height', this.value)"></div>
                        </div>
                        <div class="props-row">
                            <div class="input-group" style="width:100%">
                                <label>Slope</label>
                                <select id="prop_t_slope" style="width:100%" onchange="updateSelectedProp('slope', this.value)">
                                    <option value="1">One Side</option>
                                    <option value="2">Two Sides</option>
                                </select>
                            </div>
                        </div>
                        <div id="trap_validation" class="validation-msg"></div>
                    </div>
                    <div style="margin-top:10px; font-size:11px; color:#555; background:#eee; padding:5px; border-radius:4px;">
                        Click canvas cells to toggle panels.
                    </div>
                </div>
                <div id="props_empty" style="display:none; text-align:center; color:#888;">No array selected</div>
            </div>
            <div id="props_hint" class="props-panel" style="color:#888; text-align:center;">Select an array.</div>
        </div>

        <div id="panel_electrical" class="panel-content">
            <div class="panel-header"><h2>Strings & Inverters</h2></div>
            <div style="padding-top:10px;">
                <div id="string_list_container"></div>
                <button class="btn btn-add" style="width:100%; margin-top:5px;" onclick="addStringType()">+ Add String Type</button>
                
                <hr style="border:0; border-top:1px solid #eee; margin:20px 0;">
                
                <h3>Inverter Config</h3>
            <div class="props-row">
                <div class="input-group" style="flex:1">
                    <label>Min String</label>
                    <input type="number" id="inp_str_min" value="8" min="1" max="30">
                </div>
                <div class="input-group" style="flex:1">
                    <label>Max String</label>
                    <input type="number" id="inp_str_max" value="13" min="1" max="30">
                </div>
                <button class="btn btn-blue" style="margin-top:14px; flex:1;" onclick="autoConfigStrings()">Auto-String</button>
            </div>
            <div id="auto_str_msg" style="font-size:11px; color:#666; margin-bottom:10px; text-align:center;"></div>

            <div class="props-row">
                <div class="input-group" style="flex:1">
                    <label>Units</label>
                    <input type="number" id="inp_inverters" value="10" min="1" onchange="updateInverterConfig('count', this.value)">
                </div>
                <div class="input-group" style="flex:1">
                    <label>Cap (W)</label>
                    <input type="number" id="inp_inv_cap" value="10000" min="0" step="100" onchange="updateInverterConfig('cap', this.value)">
                </div>
            </div>
            <div class="props-row">
                <div class="input-group" style="flex:1">
                    <label>MPPTs/Inv</label>
                    <input type="number" id="inp_mppts" value="2" min="1" onchange="updateInverterConfig('mppt', this.value)">
                </div>
                <div class="input-group" style="flex:1">
                    <label>Str/MPPT</label>
                    <input type="number" id="inp_spm" value="2" min="1" onchange="updateInverterConfig('spm', this.value)">
                </div>
                <div class="input-group" style="flex:1">
                    <label>Panel (W)</label>
                    <input type="number" id="inp_panel_w" value="400" min="0" step="5" onchange="updateInverterConfig('watts', this.value)">
                </div>
            </div>
        </div>
    </div>
    <div id="panel_algo" class="panel-content">
        <div class="panel-header"><h2>Fill Algorithm</h2></div>
        <div style="padding-top:15px;">
            <div class="input-group" style="margin-bottom:10px;">
                <label>Strategy</label>
                <select id="sel_fill_algo" style="width:100%" onchange="updateAlgo('fillAlgorithm', this.value)">
                    <option value="linear">Linear (Sequential)</option>
                    <option value="proximity">Proximity (Nearest)</option>
                </select>
            </div>
            <div class="input-group" style="margin-bottom:15px;">
                <label>Fill Start Position</label>
                <select id="sel_fill_order" style="width:100%" onchange="updateAlgo('fillOrder', this.value)">
                    <option value="top">Top (Screen Top)</option>
                    <option value="bottom">Bottom (Screen Bottom)</option>
                </select>
            </div>

            <div class="input-group" style="flex-direction:row; align-items:center; gap:10px;">
                <input type="checkbox" id="chk_cross_group" style="width:auto;" onchange="updateAlgo('crossGroup', this.checked)">
                <label style="margin:0; font-size:13px; font-weight:normal; cursor:pointer;" for="chk_cross_group">Allow Strings to Cross Groups</label>
            </div>
            <div style="font-size:11px; color:#666; margin-top:5px; margin-left:24px; margin-bottom:15px;">
                If unchecked, strings will be cut off at the end of each array group.
            </div>

            <div class="input-group" style="flex-direction:row; align-items:center; gap:10px;">
                <input type="checkbox" id="chk_strict_orient" style="width:auto;" onchange="updateAlgo('strictOrient', this.checked)">
                <label style="margin:0; font-size:13px; font-weight:normal; cursor:pointer;" for="chk_strict_orient">Strict Orientation (No Crossing)</label>
            </div>
            <div style="font-size:11px; color:#666; margin-top:5px; margin-left:24px;">
                If checked, strings will be cut off when moving between arrays with different Slope Directions (e.g. South to West), even within the same group.
            </div>

            <hr style="border:0; border-top:1px solid #eee; margin:15px 0;">
            <button class="btn btn-blue" style="width:100%" onclick="runOptimization()">Optimize String Order</button>
           <div id="opt_result" style="font-size:11px; color:#666; margin-top:5px; text-align:center; min-height:15px;"></div>
        </div>
    </div>

    <div id="panel_filters" class="panel-content">
        <div class="panel-header"><h2>Visibility Filters</h2></div>
        <div style="padding:15px; display:flex; flex-direction:column; height:100%;">
            <div style="margin-bottom:5px; font-weight:bold; color:#555; font-size:12px;">Groups</div>
            <div id="filter_groups_list" class="array-list" style="flex:1; max-height:200px; min-height:100px;"></div>
            
            <div style="margin:15px 0 5px 0; font-weight:bold; color:#555; font-size:12px; display:flex; justify-content:space-between; align-items:center;">
                <span>Strings</span>
                <div>
                    <button class="btn btn-gray" style="padding:2px 6px; font-size:10px;" onclick="toggleAllStrings(true)">All</button>
                    <button class="btn btn-gray" style="padding:2px 6px; font-size:10px;" onclick="toggleAllStrings(false)">None</button>
                </div>
            </div>
            <div id="filter_strings_list" class="array-list" style="flex:1;"></div>
        </div>
    </div>

    <div id="panel_materials" class="panel-content">
        <div class="panel-header"><h2>Material Estimates</h2></div>
            <div style="padding-top:10px;">
                <div class="props-row">
                <div class="input-group" style="flex:1">
                    <label>Panels per Rail</label>
                    <input type="number" id="mat_ppr" value="4" min="1" onchange="calculateMaterials()">
                </div>
                <div class="input-group" style="flex:1">
                    <label>Rails per Group</label>
                    <input type="number" id="mat_rpp" value="2" min="1" onchange="calculateMaterials()">
                </div>
                <div class="input-group" style="flex:1">
                    <label>L-feet per Rail</label>
                    <input type="number" id="mat_lpr" value="2" min="0" onchange="calculateMaterials()">
                </div>
            </div>

            <hr style="border:0; border-top:1px solid #eee; margin:15px 0;">
                
                <button class="btn btn-blue" style="width:100%" onclick="showMaterialModal()">View Full Summary</button>
            </div>
        </div>
    </div>

    <div class="top-actions">
        <div class="tool-group">
            <button class="btn-tool active" id="btn_tool_move" onclick="setTool('move')" title="Move/Select Tool">‚ú•</button>
            <button class="btn-tool" id="btn_tool_pan" onclick="setTool('pan')" title="Pan Tool">‚úã</button>
            <div style="width:1px; background:#eee;"></div>
            <button class="btn-tool" id="btn_snap" onclick="toggleSnap()" title="Snap to Grid (20px)">‚ßâ</button>
        </div>
        <button class="btn btn-danger" onclick="clearAll()">Clear All</button>
        <button class="btn btn-blue" onclick="saveConfig()">Save</button>
        <button class="btn btn-gray" onclick="document.getElementById('file_loader').click()">Load</button>
        <button class="btn btn-gray" onclick="openPrintModal()">Print</button>
        <input type="file" id="file_loader" accept=".json" onchange="loadConfig(this)">
    </div>
    
    <div id="stats_bar" class="stats-bar"></div>

    <div id="mat_modal" class="modal-overlay" onclick="if(event.target===this) closeMatModal()">
        <div class="modal-content">
            <div class="modal-header">
                <h2 style="margin:0; font-size:18px; color:#333;">Material Estimate Summary</h2>
                <button class="close-modal" onclick="closeMatModal()">&times;</button>
            </div>
            <div id="material_summary_content"></div>
            <div style="margin-top:20px; text-align:right;">
                <button class="btn btn-gray" onclick="closeMatModal()">Close</button>
            </div>
        </div>
    </div>

    <div id="print_modal" class="modal-overlay" onclick="if(event.target===this) document.getElementById('print_modal').style.display='none'">
        <div class="modal-content" style="width: 400px;">
            <div class="modal-header">
                <h2 style="margin:0; font-size:18px; color:#333;">Select Arrays to Print</h2>
                <button class="close-modal" onclick="document.getElementById('print_modal').style.display='none'">&times;</button>
            </div>
            <div style="margin-bottom:10px; display:flex; gap:10px;">
                <button class="btn btn-gray" style="padding:2px 8px; font-size:11px;" onclick="togglePrintChecks(true)">Select All</button>
                <button class="btn btn-gray" style="padding:2px 8px; font-size:11px;" onclick="togglePrintChecks(false)">Deselect All</button>
            </div>
            <div id="print_list_container" class="print-list"></div>
            <div style="margin-top:10px; text-align:right; display:flex; justify-content:flex-end; gap:10px;">
                <button class="btn btn-gray" onclick="document.getElementById('print_modal').style.display='none'">Cancel</button>
                <button class="btn btn-blue" onclick="confirmPrint()">Generate Report</button>
            </div>
        </div>
    </div>

    <div id="canvas-container">
        <canvas id="solarCanvas"></canvas>
        
        <div class="zoom-controls">
            <button class="zoom-btn" onclick="zoomIn()" title="Zoom In">+</button>
            <button class="zoom-btn" onclick="zoomOut()" title="Zoom Out">-</button>
            <button class="zoom-btn" onclick="autoFitView()" title="Fit to Screen">‚õ∂</button>
        </div>
        <div id="tooltip" class="tooltip"></div>
    </div>

    <script>
        // --- DRAWING CONSTANTS ---
        const DRAW_OPTS = {
            panelWidth: 35,
            panelHeight: 50,
            gapX: 3,
            gapY: 3,
            tableMargin: 35,
            inverterHeight: 120
        };

        // --- VIEW STATE ---
        let view = {
            scale: 1,
            x: 0,
            y: 0,
            isDragging: false,
            lastX: 0,
            lastY: 0
        };

        // --- APP STATE ---
        let state = {
            tables: new Map(),
            nextId: 1,
            stringTypes: [
                { id: 1, count: 13, size: 8 },
                { id: 2, count: 7, size: 9 }
            ],
            inverters: 10,
            inverterCapacity: 10000,
            mpptCount: 2,
            stringsPerMppt: 2,
            panelWatts: 400,
            fillOrder: 'top',
            fillAlgorithm: 'linear',
            allowCrossGroup: true,
            strictOrient: false,
            snapToGrid: false,
            selectedId: null,
            stringPermutation: null,
            hiddenGroups: new Set(),
            hiddenStrings: new Set()
        };

        // --- HELPER: MASK GENERATION ---
        function generateMask(data) {
            let rows, cols;
            let gridMap = [];

            if (data.type === 'rect') {
                rows = data.rows;
                cols = data.cols;
                for(let r=0; r<rows; r++) {
                    let rowArr = new Array(cols).fill(1); // 1 = Active
                    gridMap.push(rowArr);
                }
            } else {
                rows = data.rows;
                const top = data.topBase;
                const bottom = data.bottomBase;
                cols = Math.max(top, bottom); 
                
                for(let r=0; r<rows; r++) {
                    let progress = (rows === 1) ? 1 : r / (rows - 1);
                    let width = Math.round(top + (bottom - top) * progress);
                    let rowArr = new Array(cols).fill(0);
                    
                    if (data.slopeType === "2") {
                        let offset = Math.floor((cols - width) / 2);
                        for(let k=0; k<width; k++) { if (offset + k < cols) rowArr[offset + k] = 1; }
                    } else {
                        for(let k=0; k<width; k++) rowArr[k] = 1;
                    }
                    gridMap.push(rowArr);
                }
            }
            return gridMap;
        }

        // --- INITIALIZATION ---
        function init() {
            const localData = localStorage.getItem('solar_layout_cfg');
            let loaded = false;
            
            if (localData) {
                try {
                    const imported = JSON.parse(localData);
                    state.nextId = imported.nextId || 100;
                    state.stringTypes = imported.stringTypes || []; 
                    state.inverters = imported.inverters || 10;
                    state.inverterCapacity = imported.inverterCapacity || 10000;
                    state.mpptCount = imported.mpptCount || 2;
                    state.stringsPerMppt = imported.stringsPerMppt || 2;
                    state.stringsPerMppt = imported.stringsPerMppt || 2;
                    state.panelWatts = imported.panelWatts || 400;
                    state.fillOrder = imported.fillOrder || 'top';
                    state.fillAlgorithm = imported.fillAlgorithm || 'linear';
                    state.allowCrossGroup = (imported.allowCrossGroup !== undefined) ? imported.allowCrossGroup : true;
                    state.strictOrient = (imported.strictOrient !== undefined) ? imported.strictOrient : false;
                    state.tables = new Map(imported.tables);
                    loaded = true;
                } catch(e) { console.error("Local storage error", e); }
            }

            if (!loaded) {
                const defaults = [
                    { name: "Array 1", grp: "South Roof" }, 
                    { name: "Array 2", grp: "South Roof" },
                    { name: "Array 3", grp: "West Garage" },
                    { name: "Array 4", grp: "West Garage" }
                ];
                
                defaults.forEach(d => {
                    const id = state.nextId++;
                    const tData = { 
                        id: id, name: d.name, group: d.grp, type: 'rect', 
                        rows: 2, cols: 11,
                    topBase: 8, bottomBase: 12, slopeType: "2",
                    railDir: 'row', slopeDir: 'S'
                };
                tData.mask = generateMask(tData);
                    state.tables.set(id, tData);
                });
            }

            document.getElementById('inp_inverters').value = state.inverters;
            document.getElementById('inp_inv_cap').value = state.inverterCapacity;
            document.getElementById('inp_mppts').value = state.mpptCount;
            document.getElementById('inp_spm').value = state.stringsPerMppt;
            document.getElementById('inp_panel_w').value = state.panelWatts;
            document.getElementById('sel_fill_order').value = state.fillOrder;
            document.getElementById('sel_fill_algo').value = state.fillAlgorithm;
            
            // Init UI State
            const algoDisabled = (state.fillAlgorithm === 'proximity');
            document.getElementById('sel_fill_order').disabled = algoDisabled;
            document.getElementById('sel_fill_order').style.opacity = algoDisabled ? '0.5' : '1';

            document.getElementById('chk_cross_group').checked = state.allowCrossGroup;
            document.getElementById('chk_strict_orient').checked = state.strictOrient;
            window.addEventListener('resize', handleResize);
            renderUI();
            
            setTimeout(() => { handleResize(); autoFitView(); }, 100);
        }
        function saveToLocal() {
            const exportData = { ...state, tables: Array.from(state.tables.entries()), selectedId: null };
            localStorage.setItem('solar_layout_cfg', JSON.stringify(exportData));
        }

        function handleResize() {
            const container = document.getElementById('canvas-container');
            const canvas = document.getElementById('solarCanvas');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            draw();
        }

        // --- ZOOM & PAN ---
        function zoomIn() { applyZoom(1.2); }
        function zoomOut() { applyZoom(0.8); }
        
        function applyZoom(factor) {
            const canvas = document.getElementById('solarCanvas');
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            
            // Zoom towards center of screen
            view.x = cx - (cx - view.x) * factor;
            view.y = cy - (cy - view.y) * factor;
            view.scale *= factor;
            draw();
        }

        function autoFitView() {
            const data = generateData(); // Generate to get bounds
            if(data.tables.length === 0) return;

            // Calculate bounding box of all content
            let globalMaxCols = 1;
            let globalMaxRows = 1;
            
            // We need to estimate World Width/Height
            // The logic in draw() relies on cellW/cellH derived from max dimensions
            data.tables.forEach(t => {
                if(t.bounds.cols > globalMaxCols) globalMaxCols = t.bounds.cols;
                if(t.bounds.rows > globalMaxRows) globalMaxRows = t.bounds.rows;
            });

            const cellW = (globalMaxCols * (DRAW_OPTS.panelWidth + DRAW_OPTS.gapX)) + DRAW_OPTS.tableMargin;
            const cellH = (globalMaxRows * (DRAW_OPTS.panelHeight + DRAW_OPTS.gapY)) + DRAW_OPTS.tableMargin + 30;

            const worldW = (state.gridCols * cellW) + DRAW_OPTS.tableMargin;
            const worldH = (state.gridRows * cellH) + DRAW_OPTS.tableMargin + DRAW_OPTS.inverterHeight + 50;

            const canvas = document.getElementById('solarCanvas');
            const scaleX = (canvas.width - 60) / worldW; // 60px padding
            const scaleY = (canvas.height - 60) / worldH;
            
            view.scale = Math.min(scaleX, scaleY, 1.5); // Cap max zoom
            
            // Center
            view.x = (canvas.width - worldW * view.scale) / 2;
            view.y = (canvas.height - worldH * view.scale) / 2;
            
            draw();
        }

        // --- MOUSE HANDLERS (PAN/ZOOM) ---
        const container = document.getElementById('canvas-container');
        
        container.addEventListener('wheel', (e) => {
            e.preventDefault();
            const factor = e.deltaY > 0 ? 0.9 : 1.1;
            
            const rect = container.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            view.x = mouseX - (mouseX - view.x) * factor;
            view.y = mouseY - (mouseY - view.y) * factor;
            view.scale *= factor;
            draw();
        });

        container.addEventListener('mousedown', (e) => {
            // If dragging logic vs clicking logic
            view.isDragging = true;
            view.lastX = e.clientX;
            view.lastY = e.clientY;
            // Don't draw yet, wait for move
        });

        window.addEventListener('mousemove', (e) => {
            const rect = container.getBoundingClientRect();
            const mx = (e.clientX - rect.left - view.x) / view.scale;
            const my = (e.clientY - rect.top - view.y) / view.scale;

            // Group Dragging Logic
            if (activeGroupDrag) {
                e.preventDefault();
                e.stopPropagation();

                const dx = mx - activeGroupDrag.startX;
                const dy = my - activeGroupDrag.startY;
                let movedCount = 0;

                // Log every ~10th frame to avoid spam but show activity
                if (Math.random() < 0.05) {
                    console.log('[MouseMove] Dragging Group:', activeGroupDrag.name, 'Delta:', dx.toFixed(1), dy.toFixed(1));
                }

                state.tables.forEach(t => {
                    if (t.group === activeGroupDrag.name) {
                        const snapshot = activeGroupDrag.snapshot[t.id];
                        if (snapshot) {
                            let nx = snapshot.x + dx;
                            let ny = snapshot.y + dy;

                            if (state.snapToGrid) {
                                nx = Math.round(nx / 20) * 20;
                                ny = Math.round(ny / 20) * 20;
                            }

                            t.x = nx;
                            t.y = ny;
                            // Update map value reference (redundant but safe)
                            state.tables.set(t.id, t);
                            movedCount++;
                        }
                    }
                });

                if (movedCount > 0) {
                    draw();
                }
                return;
            }

            // Priority 2: Anchor Dragging
            if (isAnchorDrag && dragTarget) {
                const t = state.tables.get(dragTarget.id);
                if (t) {
                    let nx = mx - dragOffset.x;
                    let ny = my - dragOffset.y;

                    if (state.snapToGrid) {
                        const gridSize = 20;
                        nx = Math.round(nx / gridSize) * gridSize;
                        ny = Math.round(ny / gridSize) * gridSize;
                    }

                    t.x = nx;
                    t.y = ny;
                    state.tables.set(t.id, t);
                    draw();
                }
                return;
            }

            // Priority 3: Panning
            if (view.isDragging) {
                const dx = e.clientX - view.lastX;
                const dy = e.clientY - view.lastY;
                view.x += dx;
                view.y += dy;
                view.lastX = e.clientX;
                view.lastY = e.clientY;
                draw();
                return;
            }

            // Priority 4: Cursor Hover Effects
            if (activeTool === 'move') {
                const data = generateData();
                let cursor = 'default';
                let tooltipShown = false;
                let hoverHandle = false;

                // Check Group Handles for Hover Cursor
                for(let gh of groupHandles) {
                    if(mx >= gh.x && mx <= gh.x + gh.w && my >= gh.y && my <= gh.y + gh.h) {
                        cursor = 'move';
                        hoverHandle = true;
                        break;
                    }
                }

                if (!hoverHandle) {
                    for(let t of data.tables) {
                        const local = getLocalCoords(mx, my, t);
                        const dist = Math.sqrt(local.x * local.x + local.y * local.y);
                        
                        if (state.selectedId === t.id && dist <= 25) {
                            cursor = 'move';
                            break;
                        }

                        if (local.x >= 0 && local.x <= t.layout.w && local.y >= 0 && local.y <= t.layout.h) {
                            if (state.selectedId === t.id) {
                                cursor = 'crosshair'; 
                                // ... Tooltip logic ...
                                const pOffsetX = 5; const pOffsetY = 20;
                                const isVert = t.railDir === 'col';
                                const pW = isVert ? DRAW_OPTS.panelHeight : DRAW_OPTS.panelWidth;
                                const pH = isVert ? DRAW_OPTS.panelWidth : DRAW_OPTS.panelHeight;
                                const c = Math.floor((local.x - pOffsetX) / (pW + DRAW_OPTS.gapX));
                                const r = Math.floor((local.y - pOffsetY) / (pH + DRAW_OPTS.gapY));
                                
                                if (t.grid[r] && t.grid[r][c]) {
                                    const panel = t.grid[r][c];
                                    const tooltip = document.getElementById('tooltip');
                                    tooltip.style.display = 'block';
                                    tooltip.style.left = (e.clientX + 10) + 'px';
                                    tooltip.style.top = (e.clientY + 10) + 'px';
                                    tooltip.innerHTML = `S${panel.stringId} (${panel.stringType}) | P${panel.panelNum}`;
                                    tooltipShown = true;
                                }
                            } else {
                                cursor = 'pointer'; 
                            }
                            break; 
                        }
                    }
                }
                canvas.style.cursor = cursor;
                if (!tooltipShown) document.getElementById('tooltip').style.display = 'none';
            } else {
                canvas.style.cursor = 'grab';
            }
        });

        window.addEventListener('mouseup', () => {
            view.isDragging = false;
        });


        // --- UI LOGIC ---
        function toggleAllStrings(show) {
            state.hiddenStrings.clear();
            if(!show) {
                let total = 0;
                state.stringTypes.forEach(t => total += t.count);
                for(let i=1; i<=total; i++) state.hiddenStrings.add(i);
            }
            renderFilters();
            draw();
        }

        function toggleFilterGroup(g) {
            if(state.hiddenGroups.has(g)) state.hiddenGroups.delete(g);
            else state.hiddenGroups.add(g);
            draw();
        }

        function toggleFilterString(id) {
            if(state.hiddenStrings.has(id)) state.hiddenStrings.delete(id);
            else state.hiddenStrings.add(id);
            draw();
        }

        function renderFilters() {
            // Groups
            const groups = Array.from(new Set(Array.from(state.tables.values()).map(t => t.group))).sort();
            const gList = document.getElementById('filter_groups_list');
            if(gList) {
                gList.innerHTML = '';
                groups.forEach(g => {
                    const isVis = !state.hiddenGroups.has(g);
                    const item = document.createElement('div');
                    item.className = 'array-item';
                    item.innerHTML = `<label style="display:flex; align-items:center; width:100%; cursor:pointer; margin:0;"><input type="checkbox" ${isVis?'checked':''} onchange="toggleFilterGroup('${g}')" style="margin-right:8px;"> ${g}</label>`;
                    gList.appendChild(item);
                });
            }

            // Strings
            const sList = document.getElementById('filter_strings_list');
            if(sList) {
                sList.innerHTML = '';
                let totalStrings = 0;
                state.stringTypes.forEach(t => totalStrings += t.count);
                
                // If optimized, we need to map IDs correctly, but IDs are always 1..N
                for(let i=1; i<=totalStrings; i++) {
                    const isVis = !state.hiddenStrings.has(i);
                    const item = document.createElement('div');
                    item.className = 'array-item';
                    const hue = (i * 137.5) % 360;
                    const color = `hsla(${hue}, 70%, 50%, 1)`;
                    
                    item.innerHTML = `<label style="display:flex; align-items:center; width:100%; cursor:pointer; margin:0;">
                        <input type="checkbox" ${isVis?'checked':''} onchange="toggleFilterString(${i})" style="margin-right:8px;"> 
                        <span style="display:inline-block; width:10px; height:10px; border-radius:50%; background:${color}; margin-right:5px;"></span>
                        S${i}
                    </label>`;
                    sList.appendChild(item);
                }
            }
        }
        function renderUI() {
            renderArrayList();
            renderStringList();
            renderFilters();
            updatePropsPanel();
            calculateMaterials();
        }

        function renderArrayList() {
            const container = document.getElementById('array_list');
            container.innerHTML = '';
            
            const arrays = Array.from(state.tables.values());
            // Sort by Group then Name
            arrays.sort((a,b) => {
                if(a.group !== b.group) return a.group.localeCompare(b.group);
                return a.name.localeCompare(b.name);
            });

            arrays.forEach(data => {
                const el = document.createElement('div');
                const isSelected = state.selectedId === data.id;
                el.className = 'array-item' + (isSelected ? ' selected' : '');
                el.innerHTML = `<div><span class="array-group-tag">${data.group}</span> ${data.name}</div>`;
                el.onclick = () => selectArray(data.id);
                container.appendChild(el);
            });
        }

        function selectArray(id) {
            state.selectedId = id;
            renderArrayList();
            updatePropsPanel();
            draw();
        }

        function addNewArray() {
            const id = state.nextId++;
            const newData = { 
            id: id, name: `Array ${id}`, group: 'New Group', type: 'rect', 
            rows: 2, cols: 11, topBase: 8, bottomBase: 12, slopeType: "2",
            railDir: 'row', slopeDir: 'S', manualRot: false, rot: 0
        };
        newData.mask = generateMask(newData);
            state.tables.set(id, newData);
            selectArray(id);
            calculateMaterials();
            saveToLocal();
        }

        function updatePropsPanel() {
            const hint = document.getElementById('props_hint');
            const panel = document.getElementById('props_panel');
            const emptyState = document.getElementById('props_empty');
            const activeState = document.getElementById('props_active');

            if (!state.selectedId) {
                hint.style.display = 'block'; panel.style.display = 'none'; return;
            }

            hint.style.display = 'none'; panel.style.display = 'block';
            const data = state.tables.get(state.selectedId);

            if (data) {
                emptyState.style.display = 'none';
                activeState.style.display = 'block';
                
                document.getElementById('prop_name').value = data.name;
                document.getElementById('prop_group').value = data.group;
                document.getElementById('prop_shape').value = data.type;
                
                const isManual = data.manualRot || false;
                document.getElementById('chk_manual_rot').checked = isManual;
                const rotInput = document.getElementById('prop_rot');
                rotInput.value = data.rot || 0;
                rotInput.disabled = !isManual;

                document.getElementById('prop_rail_dir').value = data.railDir || 'row';
                document.getElementById('prop_slope_dir').value = data.slopeDir || 'S';

            const rectInputs = document.getElementById('shape_rect_inputs');
                const trapInputs = document.getElementById('shape_trap_inputs');

                if (data.type === 'rect') {
                    rectInputs.style.display = 'block';
                    trapInputs.style.display = 'none';
                    document.getElementById('prop_r_rows').value = data.rows;
                    document.getElementById('prop_r_cols').value = data.cols;
                } else {
                    rectInputs.style.display = 'none';
                    trapInputs.style.display = 'block';
                    document.getElementById('prop_t_top').value = data.topBase || 10;
                    document.getElementById('prop_t_bottom').value = data.bottomBase || 14;
                    document.getElementById('prop_t_height').value = data.rows || 3;
                    document.getElementById('prop_t_slope').value = data.slopeType || "2";
                    validateTrapezoid(data);
                }
            } else {
                emptyState.style.display = 'block';
                activeState.style.display = 'none';
            }
        }

        // --- ARRAY EDITING LOGIC ---
        function toggleMaskCell(tableId, cellR, cellC) {
            let data = state.tables.get(tableId);
            if (!data) return;

            if (!data.mask) data.mask = generateMask(data);

            data.mask[cellR][cellC] = data.mask[cellR][cellC] ? 0 : 1;
            state.tables.set(tableId, data);
            
            draw();
            calculateMaterials();
            saveToLocal();
        }
        function validateTrapezoid(data) {
            const msg = document.getElementById('trap_validation'); msg.textContent = "";
            if(data.type !== 'trap' || data.rows <=1) return;
            if (data.slopeType === "2" && (data.topBase % 2) !== (data.bottomBase % 2)) {
                msg.textContent = `Tip: Use same parity (Even/Odd) for symmetry.`;
            }
        }
        function removeSelectedArray() {
            if (!state.selectedId) return;
            state.tables.delete(state.selectedId);
            state.selectedId = null;
            renderUI(); draw(); calculateMaterials();
            saveToLocal();
        }
        
        function updateSelectedProp(prop, val) {
            if (!state.selectedId) return;
            let data = state.tables.get(state.selectedId);
            if (!data) return;
            
            let dimChanged = false;
            if (prop === 'name') data.name = val;
            if (prop === 'group') data.group = val;
            if (prop === 'type') {
                data.type = val; dimChanged = true;
                if (val === 'trap' && !data.topBase) { data.topBase = 8; data.bottomBase = 12; data.rows = 3; data.slopeType = "2"; }
                if (val === 'rect' && !data.cols) { data.rows = 2; data.cols = 11; }
            }
            if (prop === 'rows') { data.rows = parseInt(val)||1; dimChanged = true; }
            if (prop === 'cols') { data.cols = parseInt(val)||1; dimChanged = true; }
            if (prop === 'top') { data.topBase = parseInt(val)||1; dimChanged = true; }
            if (prop === 'bottom') { data.bottomBase = parseInt(val)||1; dimChanged = true; }
            if (prop === 'height') { data.rows = parseInt(val)||1; dimChanged = true; }
            if (prop === 'slope') { data.slopeType = val; dimChanged = true; }
            
            if (prop === 'manualRot') { 
                data.manualRot = val;
                if (!val) {
                     const map = { 'S':0, 'SW':45, 'W':90, 'NW':135, 'N':180, 'NE':225, 'E':270, 'SE':315 };
                     data.rot = map[data.slopeDir || 'S'] || 0;
                }
            }
            if (prop === 'rot') { data.rot = parseInt(val) || 0; }
            if (prop === 'railDir') { data.railDir = val; }
            if (prop === 'slopeDir') { 
                data.slopeDir = val; 
                if (!data.manualRot) {
                     const map = { 'S':0, 'SW':45, 'W':90, 'NW':135, 'N':180, 'NE':225, 'E':270, 'SE':315 };
                     data.rot = map[val] || 0;
                }
            }

            if (dimChanged) data.mask = generateMask(data);
            state.tables.set(state.selectedId, data);
            
            if (prop === 'name' || prop === 'group') renderArrayList(); 
            updatePropsPanel(); draw(); calculateMaterials();
            saveToLocal();
        }
        
        // --- DATA GEN ---
        function renderStringList() { 
            const container = document.getElementById('string_list_container'); container.innerHTML = '';
            state.stringTypes.forEach((st, index) => {
                const row = document.createElement('div'); row.className = 'string-row';
                row.innerHTML = `<div class="input-group"><label>Cnt</label><input type="number" value="${st.count}" onchange="updateString(${index}, 'count', this.value)"></div>
                    <div style="font-size:12px">x</div><div class="input-group"><label>Pnl</label><input type="number" value="${st.size}" onchange="updateString(${index}, 'size', this.value)"></div>
                    <button class="btn btn-danger" onclick="removeString(${index})" style="margin-top:14px">√ó</button>`;
                container.appendChild(row);
            });
        }
        function addStringType() { state.stringTypes.push({ count: 1, size: 10 }); state.stringPermutation = null; renderStringList(); draw(); saveToLocal(); }
        function removeString(index) { state.stringTypes.splice(index, 1); state.stringPermutation = null; renderStringList(); draw(); saveToLocal(); }
        function updateString(index, f, v) { state.stringTypes[index][f] = parseInt(v) || 0; state.stringPermutation = null; draw(); saveToLocal(); }
        function updateInverterConfig(key, val) {
            const v = parseInt(val) || 0;
            if (key === 'count') state.inverters = Math.max(1, v);
            if (key === 'cap') state.inverterCapacity = v;
            if (key === 'mppt') state.mpptCount = Math.max(1, v);
            if (key === 'spm') state.stringsPerMppt = Math.max(1, v);
            if (key === 'watts') state.panelWatts = v;
            draw(); saveToLocal();
        }

        function updateAlgo(key, val) {
            if (key === 'crossGroup') state.allowCrossGroup = val;
            if (key === 'strictOrient') state.strictOrient = val;
            if (key === 'fillOrder') state.fillOrder = val;
            if (key === 'fillAlgorithm') {
                state.fillAlgorithm = val;
                // Update UI State
                const disabled = (val === 'proximity');
                document.getElementById('sel_fill_order').disabled = disabled;
                document.getElementById('sel_fill_order').style.opacity = disabled ? '0.5' : '1';
            }
            draw(); saveToLocal();
        }
        // --- CORE LOGIC ---
        function generateData() {
            // state.inverters is now the source of truth, updated by updateInverters()
            
            // 1. Strings Setup
            let rawStrings = [];
            state.stringTypes.forEach((type) => {
                for(let i=0; i<type.count; i++) {
                    rawStrings.push({ size: type.size, type: `${type.size}p` });
                }
            });

            // Optimization: Apply Shuffle (Handling Gaps)
            let strings = [];
            if (state.stringPermutation) {
                state.stringPermutation.forEach(idx => {
                    if (idx < rawStrings.length) {
                        strings.push(rawStrings[idx]);
                    } else {
                        // This is an excess capacity "Gap" string of size 1
                        strings.push({ size: 1, type: 'gap', isGap: true });
                    }
                });
            } else {
                state.stringPermutation = null;
                strings = [...rawStrings];
            }

            // Assign IDs and Colors sequentially to REAL strings
            let realStringCounter = 1;
            strings.forEach((s) => {
                if (!s.isGap) {
                    s.id = realStringCounter++;
                    const hue = (s.id * 137.5) % 360;
                    s.color = `hsla(${hue}, 70%, 50%, 1)`;
                    s.lightColor = `hsla(${hue}, 70%, 90%, 1)`;
                }
            });

            let panelStream = [];
            strings.forEach(str => {
                if (str.isGap) {
                     panelStream.push({ isGap: true });
                } else {
                    for(let p=1; p<=str.size; p++) {
                        panelStream.push({ 
                            stringId: str.id, 
                            stringType: str.type, 
                            panelNum: p, 
                            totalInString: str.size, 
                            color: str.color, 
                            lightColor: str.lightColor 
                        });
                    }
                }
            });

            // 2. Table Processing & Layout Engine
            let tablesData = [];
            let streamIdx = 0;
            let totalCapacity = 0;
            
            let rawTables = Array.from(state.tables.values());
            rawTables.sort((a,b) => {
                 if(a.group !== b.group) return a.group.localeCompare(b.group);
                 return a.name.localeCompare(b.name);
            });

            let groups = {};
            if (state.allowCrossGroup) {
                // Treat all arrays as one contiguous group to prioritize slope continuity
                groups['__Combined__'] = rawTables;
            } else {
                rawTables.forEach(t => {
                    if(!groups[t.group]) groups[t.group] = [];
                    groups[t.group].push(t);
                });
            }

            let layoutY = DRAW_OPTS.tableMargin;
            let layoutMaxW = 0;
            let layoutMaxH = 0;

            for (let grpName in groups) {
            let grpArray = groups[grpName];

            let unprocessed = [...grpArray];
            let orderedGroup = [];
            if (unprocessed.length > 0) {
                let current = unprocessed.shift();
                orderedGroup.push(current);
                while (unprocessed.length > 0) {
                    const lastSlope = current.slopeDir || 'S';
                    const nextIdx = unprocessed.findIndex(t => (t.slopeDir || 'S') === lastSlope);
                    if (nextIdx !== -1) {
                        current = unprocessed.splice(nextIdx, 1)[0];
                    } else {
                        current = unprocessed.shift();
                    }
                    orderedGroup.push(current);
                }
            }

            let groupTotalCap = 0;
            orderedGroup.forEach(t => {
                let cap = 0;
                if(t.mask) t.mask.forEach(row => row.forEach(val => cap += val));
                t._tempCap = cap; 
                totalCapacity += cap;
                groupTotalCap += cap;
            });

            let groupPanels = [];
            let layoutX = DRAW_OPTS.tableMargin + 170;
            let rowMaxH = 0;

            // --- 1. Layout Pass (Calculate Positions First) ---
            let groupLayouts = [];
            
            const getSlots = (t, rows, cols, vDir, hDir) => {
                let valid = [];
                for(let r=0; r<rows; r++) {
                    for(let c=0; c<cols; c++) {
                        if(t.mask[r][c] === 1) valid.push({r,c});
                    }
                }
                
                valid.sort((a, b) => {
                    if (t.railDir === 'col') {
                        if (a.c !== b.c) return (a.c - b.c) * hDir;
                        const isBaseCol = (hDir === 1) ? (a.c % 2 === 0) : (a.c % 2 !== 0);
                        const dir = isBaseCol ? vDir : -vDir;
                        return (a.r - b.r) * dir;
                    } else {
                        if (a.r !== b.r) return (a.r - b.r) * vDir;
                        const isBaseRow = (vDir === 1) ? (a.r % 2 === 0) : (a.r % 2 !== 0);
                        const dir = isBaseRow ? hDir : -hDir;
                        return (a.c - b.c) * dir;
                    }
                });
                return valid;
            };

            const getPos = (layout, bounds, r, c, railDir) => {
                const pOffsetX = 5; const pOffsetY = 20;
                const isVert = railDir === 'col';
                const pW = isVert ? DRAW_OPTS.panelHeight : DRAW_OPTS.panelWidth;
                const pH = isVert ? DRAW_OPTS.panelWidth : DRAW_OPTS.panelHeight;
                const lx = pOffsetX + c * (pW + DRAW_OPTS.gapX) + pW/2;
                const ly = pOffsetY + r * (pH + DRAW_OPTS.gapY) + pH/2;
                const rotRad = (layout.rot || 0) * Math.PI / 180;
                const cx = layout.w / 2; const cy = layout.h / 2;
                const dx = lx - cx; const dy = ly - cy;
                const wx = dx * Math.cos(rotRad) - dy * Math.sin(rotRad);
                const wy = dx * Math.sin(rotRad) + dy * Math.cos(rotRad);
                return { x: layout.x + cx + wx, y: layout.y + cy + wy };
            };

            orderedGroup.forEach(tConfig => {
                const rows = tConfig.mask.length;
                const cols = tConfig.mask[0].length;
                const pW = tConfig.railDir === 'col' ? DRAW_OPTS.panelHeight : DRAW_OPTS.panelWidth;
                const pH = tConfig.railDir === 'col' ? DRAW_OPTS.panelWidth : DRAW_OPTS.panelHeight;
                const pixelW = (cols * (pW + DRAW_OPTS.gapX)) + 10; 
                const pixelH = (rows * (pH + DRAW_OPTS.gapY)) + 25; 

                let finalX = tConfig.x !== undefined ? tConfig.x : layoutX;
                let finalY = tConfig.y !== undefined ? tConfig.y : layoutY;

                let defV = (state.fillOrder === 'bottom') ? -1 : 1;
                let defH = (tConfig.slopeDir || 'S').includes('W') ? -1 : 1;

                const layout = { x: finalX, y: finalY, w: pixelW, h: pixelH, rot: tConfig.rot || 0 };
                const defSlots = getSlots(tConfig, rows, cols, defV, defH);
                const pStart = defSlots.length > 0 ? getPos(layout, {rows, cols}, defSlots[0].r, defSlots[0].c, tConfig.railDir) : {x:finalX, y:finalY};
                
                groupLayouts.push({
                    config: tConfig,
                    layout: layout,
                    bounds: { rows, cols },
                    defaultSlots: defSlots, 
                    capacity: tConfig._tempCap,
                    entryPos: pStart 
                });

                layoutX += pixelW + DRAW_OPTS.tableMargin;
                rowMaxH = Math.max(rowMaxH, pixelH);
            });

            // --- 2. Fill Pass ---
            let lastPanelWorldPos = null;
            let lastSlope = null;

            const fillGridFromSlots = (mask, slots, panels) => {
                if (!slots || !Array.isArray(slots)) return mask.map(r => r.map(() => null));
                const rows = mask.length;
                const cols = mask[0].length;
                const finalGrid = Array(rows).fill(null).map(() => Array(cols).fill(null));
                slots.forEach((slot, index) => {
                    if (index < panels.length) {
                        // Only assign if it's a real panel, otherwise leave slot empty (Gap)
                        if (!panels[index].isGap) {
                            finalGrid[slot.r][slot.c] = panels[index];
                        }
                    }
                });
                return finalGrid;
            };

            while(groupLayouts.length > 0) {
                let bestIdx = 0;
                let chosenSlots = null;
                
                if (state.fillAlgorithm === 'proximity') {
                    if (lastPanelWorldPos) {
                        let minD = Infinity;
                        const combos = [{ v: 1, h: 1 }, { v: 1, h: -1 }, { v: -1, h: 1 }, { v: -1, h: -1 }];
                        groupLayouts.forEach((g, i) => {
                            combos.forEach(combo => {
                                const slots = getSlots(g.config, g.bounds.rows, g.bounds.cols, combo.v, combo.h);
                                if (slots && slots.length > 0) {
                                    const startP = getPos(g.layout, g.bounds, slots[0].r, slots[0].c, g.config.railDir);
                                    const d = Math.hypot(startP.x - lastPanelWorldPos.x, startP.y - lastPanelWorldPos.y);
                                    if (d < minD) { minD = d; bestIdx = i; chosenSlots = slots; }
                                }
                            });
                        });
                    } else {
                        let minMetric = Infinity;
                        groupLayouts.forEach((g, i) => {
                            const metric = g.layout.y * 10000 + g.layout.x;
                            if (metric < minMetric) { minMetric = metric; bestIdx = i; }
                        });
                    }
                } 

                const target = groupLayouts.splice(bestIdx, 1)[0];
                const finalSlots = chosenSlots || target.defaultSlots || []; 
                const tConfig = target.config;
                const needed = target.capacity;
                const curSlope = tConfig.slopeDir || 'S';

                while(groupPanels.length < needed && streamIdx < panelStream.length) {
                    groupPanels.push(panelStream[streamIdx++]);
                }

                if (state.strictOrient && lastSlope !== null && curSlope !== lastSlope) {
                    while(groupPanels.length > 0 && groupPanels[0].panelNum !== 1) {
                        groupPanels.shift(); 
                    }
                    while(groupPanels.length < needed && streamIdx < panelStream.length) {
                        groupPanels.push(panelStream[streamIdx++]);
                    }
                }
                lastSlope = curSlope;

                const myPanels = groupPanels.splice(0, needed);
                const grid = fillGridFromSlots(tConfig.mask, finalSlots, myPanels);
                
                if (myPanels.length > 0) {
                    const lastSlotIdx = myPanels.length - 1;
                    if (lastSlotIdx < finalSlots.length) {
                        const ls = finalSlots[lastSlotIdx];
                        lastPanelWorldPos = getPos(target.layout, target.bounds, ls.r, ls.c, tConfig.railDir);
                    }
                }

                tablesData.push({ ...tConfig, grid: grid, bounds: target.bounds, layout: target.layout, _assignedPanels: myPanels });
            }

            // Post-Group Logic: "Cross Group" Check
            // If not allowed, we check the very last panel of the last array.
            // If it is mid-string, we pop those panels off and rewind streamIdx.
            if (!state.allowCrossGroup) {
                // Iterate backwards through arrays in this group to find the last placed panel
                for(let i = tablesData.length - 1; i >= 0; i--) {
                    const t = tablesData[i];
                    if (t.group !== grpName) break; // Optimization: only check current group

                    const assigned = t._assignedPanels;
                    if (assigned && assigned.length > 0) {
                        const lastP = assigned[assigned.length - 1];
                        if (lastP.panelNum < lastP.totalInString) {
                            // Cut detected. Remove this string segment.
                            const cutId = lastP.stringId;
                            let removedCount = 0;

                            // We need to remove from the array's grid and the assigned list
                            // Backward loop on assigned panels
                            for(let k = assigned.length - 1; k >= 0; k--) {
                                if(assigned[k].stringId === cutId) {
                                    assigned.pop();
                                    removedCount++;
                                } else {
                                    break; 
                                }
                            }

                            // Re-render grid for this table
                            t.grid = fillStructure(t.mask, assigned, t.railDir, t.slopeDir);

                            // Rewind Global Stream
                            streamIdx -= removedCount;
                            
                        }
                        break; // Only check the very last string of the group
                    }
                }
            }

            
            layoutMaxW = Math.max(layoutMaxW, layoutX);
            layoutY += rowMaxH + DRAW_OPTS.tableMargin + 20; 
        }
        layoutMaxH = layoutY;

        // Calculate Placed Count
        let placedCount = 0;
        tablesData.forEach(t => t.grid.forEach(r => r.forEach(c => { if(c) placedCount++; })));

        const diff = totalCapacity - panelStream.length;
        document.getElementById('stats_bar').innerHTML = `Panels: <b>${panelStream.length}</b> | Placed: <b>${placedCount}</b> | Capacity: <b>${totalCapacity}</b>`;
        // --- INVERTER MAPPING LOGIC ---
        // 1. Identify Direction of each String
        const stringDirMap = new Map();
        tablesData.forEach(t => {
            t.grid.forEach(r => r.forEach(p => {
                if(p) {
                    if (!stringDirMap.has(p.stringId)) stringDirMap.set(p.stringId, t.slopeDir || 'S');
                }
            }));
        });

        let inverters = [];
        for(let k=0; k<state.inverters; k++) {
            let mppts = [];
            for(let m=0; m<state.mpptCount; m++) mppts.push({ id: m+1, strings: [], capacity: state.stringsPerMppt, dir: null, curWatts: 0 });
            inverters.push({ id: k+1, mppts: mppts, totalPanels: 0, curWatts: 0 });
        }

        const activeStrings = [];
        const seenIds = new Set();
        tablesData.forEach(t => {
            t.grid.forEach(r => r.forEach(p => {
                if(p && !seenIds.has(p.stringId)) {
                    seenIds.add(p.stringId);
                    const s = strings.find(x => x.id === p.stringId);
                    if(s) activeStrings.push(s);
                }
            }));
        });
        
        activeStrings.sort((a,b) => b.size - a.size);

        activeStrings.forEach(s => {
            const dir = stringDirMap.get(s.id) || 'Unassigned';
            const watts = s.size * (state.panelWatts || 0);
            
            let candidates = [];
            inverters.forEach(inv => {
                inv.mppts.forEach(m => {
                    if(m.strings.length < m.capacity) {
                        if(m.dir === null || m.dir === dir) {
                            candidates.push({ inv, mppt: m, mixed: false });
                        } else {
                            candidates.push({ inv, mppt: m, mixed: true });
                        }
                    }
                });
            });

            candidates.sort((a,b) => {
                if (a.mixed !== b.mixed) return a.mixed ? 1 : -1;
                if (a.inv.curWatts !== b.inv.curWatts) return a.inv.curWatts - b.inv.curWatts;
                return a.mppt.strings.length - b.mppt.strings.length;
            });

            const best = candidates[0];
            if (best) {
                best.mppt.strings.push(s);
                if (best.mppt.dir === null) best.mppt.dir = dir;
                else if (best.mppt.dir !== dir) best.mppt.dir = 'Mixed';
                
                best.inv.totalPanels += s.size;
                best.inv.curWatts += watts;
                best.mppt.curWatts += watts;
            }
        });

        inverters.forEach(inv => {
            inv.mppts.sort((a, b) => b.strings.length - a.strings.length);
            inv.mppts.forEach((m, i) => m.id = i + 1);
        });

        return { tables: tablesData, inverters, worldW: layoutMaxW, worldH: layoutMaxH };
    }
        
        function autoFitView() {
            const data = generateData(); 
            if(data.tables.length === 0) return;

            const worldW = data.worldW;
            const worldH = data.worldH + DRAW_OPTS.inverterHeight + 50;

            const canvas = document.getElementById('solarCanvas');
            const scaleX = (canvas.width - 60) / worldW; 
            const scaleY = (canvas.height - 60) / worldH;
            
            view.scale = Math.min(scaleX, scaleY, 1.5); 
            view.x = (canvas.width - worldW * view.scale) / 2;
            view.y = (canvas.height - worldH * view.scale) / 2;
            
            draw();
        }

        function fillStructure(mask, panels, railDir, slopeDir) {
        let validSlots = [];
        const rows = mask.length;
        const cols = mask[0].length;

        for(let r=0; r<rows; r++) {
            for(let c=0; c<cols; c++) {
                if(mask[r][c] === 1) validSlots.push({ r, c });
            }
        }

        if(validSlots.length === 0) return Array(rows).fill(null).map(()=>Array(cols).fill(null));

        let vDir = (state.fillOrder === 'bottom') ? -1 : 1;
        let hDir = 1;
        if (slopeDir.includes('W')) hDir = -1;

        validSlots.sort((a, b) => {
            if (railDir === 'col') {
                if (a.c !== b.c) return (a.c - b.c) * hDir;
                const isBaseCol = (hDir === 1) ? (a.c % 2 === 0) : (a.c % 2 !== 0);
                const dir = isBaseCol ? vDir : -vDir;
                return (a.r - b.r) * dir;
            } else {
                if (a.r !== b.r) return (a.r - b.r) * vDir;
                const isBaseRow = (vDir === 1) ? (a.r % 2 === 0) : (a.r % 2 !== 0);
                const dir = isBaseRow ? hDir : -hDir;
                return (a.c - b.c) * dir;
            }
        });

        const finalGrid = Array(rows).fill(null).map(() => Array(cols).fill(null));
        validSlots.forEach((slot, index) => { 
            if (index < panels.length) finalGrid[slot.r][slot.c] = panels[index]; 
        });
        return finalGrid;
    }

        // --- DRAWING ---
        const canvas = document.getElementById('solarCanvas');
        const ctx = canvas.getContext('2d');
        // Removed clickZones, using Math-based hit test in handlers
        function getPolyIntersection(p1, p2, normal, k) {
            const dot1 = p1.x * normal.x + p1.y * normal.y;
            const dot2 = p2.x * normal.x + p2.y * normal.y;
            const t = (k - dot1) / (dot2 - dot1);
            return { x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) };
        }

        function clipPoly(poly, siteA, siteB) {
            const normal = { x: siteB.x - siteA.x, y: siteB.y - siteA.y };
            const midpoint = { x: (siteA.x + siteB.x) / 2, y: (siteA.y + siteB.y) / 2 };
            const k = midpoint.x * normal.x + midpoint.y * normal.y;
            
            const newPoly = [];
            for (let i = 0; i < poly.length; i++) {
                const cur = poly[i];
                const prev = poly[(i - 1 + poly.length) % poly.length];
                
                const curIn = (cur.x * normal.x + cur.y * normal.y) <= k;
                const prevIn = (prev.x * normal.x + prev.y * normal.y) <= k;

                if (curIn && prevIn) {
                    newPoly.push(cur);
                } else if (curIn && !prevIn) {
                    newPoly.push(getPolyIntersection(prev, cur, normal, k));
                    newPoly.push(cur);
                } else if (!curIn && prevIn) {
                    newPoly.push(getPolyIntersection(prev, cur, normal, k));
                }
            }
            return newPoly;
        }

        function getLayoutCorners(t) {
            const cx = t.layout.x + t.layout.w / 2;
            const cy = t.layout.y + t.layout.h / 2;
            const ang = (t.layout.rot || 0) * Math.PI / 180;
            const cos = Math.cos(ang), sin = Math.sin(ang);
            const hw = t.layout.w / 2, hh = t.layout.h / 2;
            
            return [
                { x: cx + (-hw * cos - -hh * sin), y: cy + (-hw * sin + -hh * cos) },
                { x: cx + (hw * cos - -hh * sin), y: cy + (hw * sin + -hh * cos) },
                { x: cx + (hw * cos - hh * sin), y: cy + (hw * sin + hh * cos) },
                { x: cx + (-hw * cos - hh * sin), y: cy + (-hw * sin + hh * cos) }
            ];
        }

        let groupHandles = [];
        let activeGroupDrag = null;

        function draw() {
            groupHandles = [];
            const data = generateData();

            // Clear Screen
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Apply Transforms
            ctx.save();
            ctx.translate(view.x, view.y);
            ctx.scale(view.scale, view.scale);

            // 0. Draw Groups & Voronoi Cells
            const groups = {};
            data.tables.forEach(t => {
                if(!groups[t.group]) groups[t.group] = [];
                groups[t.group].push(t);
            });

            ctx.lineWidth = 1;
            
            for(let grpName in groups) {
                const arrs = groups[grpName];
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                const centers = [];

                // Calculate Group Bounds
                arrs.forEach(t => {
                    const corners = getLayoutCorners(t);
                    corners.forEach(p => {
                        minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x);
                        minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y);
                    });
                    centers.push({ 
                        x: t.layout.x + t.layout.w/2, 
                        y: t.layout.y + t.layout.h/2,
                        id: t.id
                    });
                });

                const pad = 20;
                minX -= pad; minY -= pad; maxX += pad; maxY += pad;

                // Draw Group Rect
                ctx.strokeStyle = '#334155'; 
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(minX, minY, maxX - minX, maxY - minY);
                ctx.setLineDash([]);
                
                // Group Handle (Top Left Tab)
                const hH = 16; const hW = 60;
                ctx.fillStyle = '#334155';
                ctx.fillRect(minX, minY - hH, hW, hH);
                ctx.fillStyle = '#fff'; ctx.font = 'bold 10px sans-serif'; ctx.textAlign = 'left';
                ctx.fillText(grpName.substring(0, 9), minX + 4, minY - 4);
                groupHandles.push({ name: grpName, x: minX, y: minY - hH, w: hW, h: hH });

                // Draw Voronoi Cells
                if (centers.length > 1) {
                    ctx.strokeStyle = '#cbd5e1'; 
                    centers.forEach(site => {
                        let poly = [
                            {x: minX, y: minY}, {x: maxX, y: minY}, 
                            {x: maxX, y: maxY}, {x: minX, y: maxY}
                        ];

                        centers.forEach(other => {
                            if (site.id !== other.id) {
                                poly = clipPoly(poly, site, other);
                            }
                        });

                        if (poly.length > 0) {
                            ctx.beginPath();
                            ctx.moveTo(poly[0].x, poly[0].y);
                            for(let i=1; i<poly.length; i++) ctx.lineTo(poly[i].x, poly[i].y);
                            ctx.closePath();
                            ctx.stroke();
                        }
                    });
                }
            }

            // Draw Arrays
            data.tables.forEach(table => {
                // Dimensions & Transform
                const frameW = table.layout.w;
                const frameH = table.layout.h;
                const rot = (table.layout.rot || 0) * Math.PI / 180;
                
                // Calculate Center
                const cx = table.layout.x + frameW / 2;
                const cy = table.layout.y + frameH / 2;

                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(rot);
                ctx.translate(-frameW / 2, -frameH / 2); // Draw relative to top-left 0,0

                const isSelected = state.selectedId === table.id;

                // Group Label
                ctx.fillStyle = '#888'; ctx.font = 'bold 12px sans-serif'; ctx.textAlign = 'left';
                ctx.fillText(table.group.toUpperCase(), 0, -22);

                // Name
                ctx.fillStyle = isSelected ? '#3b82f6' : '#333'; ctx.font = 'bold 16px sans-serif';
                ctx.textAlign = 'left';
                const dirLabel = table.slopeDir ? `(${table.slopeDir})` : '(S)';
                ctx.fillText(`${table.name} ${dirLabel}`, 0, -5);

                // Frame & Anchor
                if(isSelected) {
                    ctx.strokeStyle = '#f59e0b'; ctx.lineWidth = 2;
                    ctx.strokeRect(-2, -2, frameW + 4, frameH + 4);

                    // Anchor Point (Blue Dot)
                    ctx.fillStyle = '#2563eb'; 
                    ctx.beginPath();
                    ctx.arc(0, 0, 8, 0, Math.PI*2);
                    ctx.fill();
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Panels
                const pOffsetX = 5;
                const pOffsetY = 20; 

                const isVert = table.railDir === 'col';
                const pW = isVert ? DRAW_OPTS.panelHeight : DRAW_OPTS.panelWidth;
                const pH = isVert ? DRAW_OPTS.panelWidth : DRAW_OPTS.panelHeight;

                let connectionPoints = {};
                
                // Group Visibility Check
                const isGroupHidden = state.hiddenGroups.has(table.group);

                table.grid.forEach((row, rIndex) => {
                    row.forEach((panel, cIndex) => {
                        const x = pOffsetX + (cIndex * (pW + DRAW_OPTS.gapX));
                        const y = pOffsetY + (rIndex * (pH + DRAW_OPTS.gapY));
                        const isMaskActive = table.mask[rIndex] && table.mask[rIndex][cIndex] === 1;

                        if (panel) {
                            // Check String Visibility
                            const isStringHidden = state.hiddenStrings.has(panel.stringId);
                            ctx.globalAlpha = (isGroupHidden || isStringHidden) ? 0.4 : 1.0;

                            ctx.fillStyle = panel.lightColor; ctx.fillRect(x, y, pW, pH);
                            ctx.strokeStyle = panel.color; ctx.lineWidth = 2; ctx.strokeRect(x, y, pW, pH);
                            ctx.fillStyle = '#000'; ctx.textAlign = 'center'; ctx.font = '9px sans-serif';
                            ctx.fillText(`S${panel.stringId}`, x + pW/2, y + pH/2 - 4);
                            ctx.font = 'bold 9px sans-serif'; ctx.fillText(panel.panelNum, x + pW/2, y + pH/2 + 7);
                            
                            // Restore Alpha
                            ctx.globalAlpha = 1.0;

                            // Local coords for wires
                            if(!connectionPoints[panel.stringId]) connectionPoints[panel.stringId] = [];
                            connectionPoints[panel.stringId].push({ x: x + pW/2, y: y + pH/2, num: panel.panelNum, color: panel.color, hidden: isStringHidden });
                        } else if (!isMaskActive) {
                            ctx.fillStyle = '#f3f4f6'; ctx.fillRect(x, y, pW, pH);
                            ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 1;
                            ctx.setLineDash([2, 2]); ctx.strokeRect(x, y, pW, pH); ctx.setLineDash([]);
                        } else {
                            ctx.fillStyle = '#fff'; ctx.fillRect(x, y, pW, pH);
                            ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1; ctx.strokeRect(x, y, pW, pH);
                        }
                    });
                });

                // Wires
                for (let sId in connectionPoints) {
                    const points = connectionPoints[sId]; points.sort((a, b) => a.num - b.num);
                    
                    // Wire opacity logic: if Group is hidden OR String is hidden
                    const isStringHidden = state.hiddenStrings.has(parseInt(sId));
                    ctx.globalAlpha = (isGroupHidden || isStringHidden) ? 0.4 : 1.0;

                    if(points.length > 1) {
                        ctx.beginPath(); ctx.strokeStyle = points[0].color; ctx.lineWidth = 3; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                        ctx.moveTo(points[0].x, points[0].y);
                        for(let i=1; i<points.length; i++) {
                            if(points[i].num === points[i-1].num + 1) ctx.lineTo(points[i].x, points[i].y);
                            else ctx.moveTo(points[i].x, points[i].y);
                        }
                        ctx.stroke();
                    }
                    points.forEach(p => {
                        ctx.beginPath(); ctx.fillStyle = '#fff'; ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = '#333'; ctx.lineWidth = 1; ctx.stroke();
                    });
                    
                    ctx.globalAlpha = 1.0;
                }
                
                ctx.restore();
            });

            // Draw Inverters (Left Side Column)
            const invColX = 15;
            let invColY = 40;
            const invCardW = 150;
            const invRowH = 14;

            ctx.fillStyle = '#333'; ctx.font = 'bold 16px sans-serif'; ctx.textAlign = 'left';
            ctx.fillText("Inverters", invColX, invColY - 10);

            data.inverters.forEach((inv) => {
                let lineCount = 0;
                inv.mppts.forEach(m => { if (m.strings.length > 0) lineCount += (1 + m.strings.length); });
                
                // Autofit height: Base(45) + Lines
                const h = Math.max(50, 45 + (lineCount * invRowH));

                // Draw Card
                ctx.fillStyle = '#fff'; ctx.strokeStyle = '#666'; ctx.lineWidth = 1;
                ctx.fillRect(invColX, invColY, invCardW, h); 
                ctx.strokeRect(invColX, invColY, invCardW, h);

                // Header
                ctx.fillStyle = '#333'; ctx.textAlign = 'center'; ctx.font = 'bold 11px sans-serif';
                ctx.fillText(`Inv ${inv.id}`, invColX + invCardW/2, invColY + 15);
                ctx.font = '10px sans-serif'; 
                const pwr = inv.curWatts ? ` - ${(inv.curWatts/1000).toFixed(1)}kW` : '';
                ctx.fillText(`${inv.totalPanels} Pnls${pwr}`, invColX + invCardW/2, invColY + 28);

                // Content
                let curY = invColY + 45;
                ctx.textAlign = 'left';

                inv.mppts.forEach(m => {
                    if (m.strings.length === 0) return;
                    // MPPT Bar
                    ctx.fillStyle = '#f3f4f6'; ctx.fillRect(invColX+2, curY - 10, invCardW-4, invRowH);
                    ctx.fillStyle = '#555'; ctx.font = 'bold 9px sans-serif';
                    ctx.fillText(`MPPT ${m.id} (${m.dir || '-'})`, invColX+5, curY);
                    curY += invRowH;

                    // Strings
                    m.strings.forEach(s => {
                        ctx.fillStyle = s.color; ctx.fillRect(invColX+10, curY-7, 8, 8);
                        ctx.fillStyle = '#000'; ctx.font = '9px sans-serif';
                        ctx.fillText(`S${s.id} (${s.type})`, invColX+22, curY);
                        curY += invRowH;
                    });
                });

                invColY += h + 15; // Gap
            });

            ctx.restore();
        }

        // --- INTERACTION HANDLERS ---
        let activeTool = 'move';
        function setTool(t) {
            activeTool = t;
            document.querySelectorAll('.btn-tool').forEach(b => { 
                if(b.id !== 'btn_snap') b.classList.remove('active'); 
            });
            document.getElementById('btn_tool_' + t).classList.add('active');
            canvas.style.cursor = t === 'pan' ? 'grab' : 'default';
            if(t === 'pan') selectArray(null); 
        }

        function toggleSnap() {
            state.snapToGrid = !state.snapToGrid;
            const btn = document.getElementById('btn_snap');
            if(state.snapToGrid) btn.classList.add('active');
            else btn.classList.remove('active');
        }

        function getLocalCoords(wx, wy, t) {
            const rotRad = (t.layout.rot || 0) * Math.PI / 180;
            const cx = t.layout.x + t.layout.w / 2;
            const cy = t.layout.y + t.layout.h / 2;
            const dx = wx - cx;
            const dy = wy - cy;
            const lx = dx * Math.cos(-rotRad) - dy * Math.sin(-rotRad);
            const ly = dx * Math.sin(-rotRad) + dy * Math.cos(-rotRad);
            return { x: lx + t.layout.w / 2, y: ly + t.layout.h / 2 };
        }

        let dragTarget = null;
        let dragOffset = { x: 0, y: 0 };
        let isAnchorDrag = false;
        
        container.addEventListener('mousedown', (e) => {
            e.preventDefault(); 
            const rect = container.getBoundingClientRect();
            const mx = (e.clientX - rect.left - view.x) / view.scale;
            const my = (e.clientY - rect.top - view.y) / view.scale;
            
            // DEBUG: Mouse Click
            console.log('[MouseDown] Screen:', e.clientX, e.clientY, 'World:', mx.toFixed(1), my.toFixed(1));
            console.log('[MouseDown] Active Group Handles:', JSON.parse(JSON.stringify(groupHandles)));

            // 1. Pan Tool Override
            if (activeTool === 'pan') {
                view.isDragging = true;
                view.lastX = e.clientX;
                view.lastY = e.clientY;
                canvas.style.cursor = 'grabbing';
                return;
            }
            
            const data = generateData();

            // Check Group Handles
            for(let gh of groupHandles) {
                if(mx >= gh.x && mx <= gh.x + gh.w && my >= gh.y && my <= gh.y + gh.h) {
                    console.log('[MouseDown] Hit Group Handle:', gh.name);
                    const snapshot = {};
                    
                    // Capture current visual positions (resolving undefined state)
                    data.tables.forEach(t => {
                        if(t.group === gh.name) {
                            snapshot[t.id] = { x: t.layout.x, y: t.layout.y };
                        }
                    });
                    
                    activeGroupDrag = { name: gh.name, startX: mx, startY: my, snapshot };
                    return;
                }
            }
            
            console.log('[MouseDown] No handle hit. Checking arrays...');

            let hitArray = null;
            let hitAnchor = false;

            for(let i = data.tables.length - 1; i >= 0; i--) {
                const t = data.tables[i];
                const local = getLocalCoords(mx, my, t);
                const dist = Math.sqrt(local.x * local.x + local.y * local.y);

                // Check Anchor (Radius 25)
                if (dist <= 25) {
                    hitArray = t;
                    hitAnchor = true;
                    break;
                }

                // Check Body
                if (local.x >= 0 && local.x <= t.layout.w && local.y >= 0 && local.y <= t.layout.h) {
                    hitArray = t;
                    hitAnchor = false;
                    break;
                }
            }

            if (hitArray) {
                view.isDragging = false; 
                
                // Check previous state
                const wasSelected = (state.selectedId === hitArray.id);

                if (!wasSelected) {
                    selectArray(hitArray.id);
                }

                if (hitAnchor) {
                    dragTarget = hitArray;
                    dragOffset = { x: mx - hitArray.layout.x, y: my - hitArray.layout.y };
                    isAnchorDrag = true;
                } else {
                    // Only toggle cell if the array was ALREADY selected
                    // Only toggle cell if the array was ALREADY selected
                    if (wasSelected) {
                        const local = getLocalCoords(mx, my, hitArray);
                        const pOffsetX = 5; const pOffsetY = 20;
                        const isVert = hitArray.railDir === 'col';
                        const pW = isVert ? DRAW_OPTS.panelHeight : DRAW_OPTS.panelWidth;
                        const pH = isVert ? DRAW_OPTS.panelWidth : DRAW_OPTS.panelHeight;
                        
                        const cIndex = Math.floor((local.x - pOffsetX) / (pW + DRAW_OPTS.gapX));
                        const rIndex = Math.floor((local.y - pOffsetY) / (pH + DRAW_OPTS.gapY));

                        if (rIndex >= 0 && rIndex < hitArray.bounds.rows && cIndex >= 0 && cIndex < hitArray.bounds.cols) {
                            toggleMaskCell(hitArray.id, rIndex, cIndex);
                        }
                    }
                }
                return; 
            }

            if (state.selectedId) selectArray(null); 
            view.isDragging = true;
            view.lastX = e.clientX;
            view.lastY = e.clientY;
            canvas.style.cursor = 'grabbing';
        });

        window.addEventListener('mousemove', (e) => {
            const rect = container.getBoundingClientRect();
            const mx = (e.clientX - rect.left - view.x) / view.scale;
            const my = (e.clientY - rect.top - view.y) / view.scale;

            if (activeGroupDrag) {
                e.preventDefault(); // Prevent selection
                const dx = mx - activeGroupDrag.startX;
                const dy = my - activeGroupDrag.startY;
                
                let movedCount = 0;
                state.tables.forEach(t => {
                    // Check if this table belongs to the group being dragged
                    if (t.group === activeGroupDrag.name) {
                        // Check if we have a snapshot for this table
                        const startPos = activeGroupDrag.snapshot[t.id];
                        if (startPos) {
                            let nx = startPos.x + dx;
                            let ny = startPos.y + dy;
                            
                            if (state.snapToGrid) {
                                nx = Math.round(nx / 20) * 20;
                                ny = Math.round(ny / 20) * 20;
                            }
                            
                            t.x = nx;
                            t.y = ny;
                            state.tables.set(t.id, t);
                            movedCount++;
                        } else {
                            // Debug mismatch
                            console.warn(`[MouseMove] Table ${t.id} in group ${t.group} missing from snapshot`, Object.keys(activeGroupDrag.snapshot));
                        }
                    }
                });

                if (movedCount > 0) {
                    draw();
                } else {
                    console.warn('[MouseMove] Active drag but 0 tables moved. Name:', activeGroupDrag.name);
                }
                return;
            }

            // Priority 1: Anchor Dragging
            if (isAnchorDrag && dragTarget) {
                const t = state.tables.get(dragTarget.id);
                if (t) {
                    let nx = mx - dragOffset.x;
                    let ny = my - dragOffset.y;

                    // Snap Logic
                    if (state.snapToGrid) {
                        const gridSize = 20;
                        nx = Math.round(nx / gridSize) * gridSize;
                        ny = Math.round(ny / gridSize) * gridSize;
                    }

                    t.x = nx;
                    t.y = ny;
                    state.tables.set(t.id, t);
                    draw();
                }
                return;
            }

            // Priority 2: Panning
            if (view.isDragging) {
                const dx = e.clientX - view.lastX;
                const dy = e.clientY - view.lastY;
                view.x += dx;
                view.y += dy;
                view.lastX = e.clientX;
                view.lastY = e.clientY;
                draw();
                return;
            }

            // Priority 3: Cursor Hover Effects
            if (activeTool === 'move') {
                const data = generateData();
                let cursor = 'default';
                let tooltipShown = false;

                for(let t of data.tables) {
                    const local = getLocalCoords(mx, my, t);
                    const dist = Math.sqrt(local.x * local.x + local.y * local.y);
                    
                    // Anchor Hover
                    if (state.selectedId === t.id && dist <= 25) {
                        cursor = 'move';
                        break;
                    }

                    // Body Hover
                    if (local.x >= 0 && local.x <= t.layout.w && local.y >= 0 && local.y <= t.layout.h) {
                        if (state.selectedId === t.id) {
                            cursor = 'crosshair'; 
                            
                            const pOffsetX = 5; const pOffsetY = 20;
                            const isVert = t.railDir === 'col';
                            const pW = isVert ? DRAW_OPTS.panelHeight : DRAW_OPTS.panelWidth;
                            const pH = isVert ? DRAW_OPTS.panelWidth : DRAW_OPTS.panelHeight;
                            const c = Math.floor((local.x - pOffsetX) / (pW + DRAW_OPTS.gapX));
                            const r = Math.floor((local.y - pOffsetY) / (pH + DRAW_OPTS.gapY));
                            
                            if (t.grid[r] && t.grid[r][c]) {
                                const panel = t.grid[r][c];
                                const tooltip = document.getElementById('tooltip');
                                tooltip.style.display = 'block';
                                tooltip.style.left = (e.clientX + 10) + 'px';
                                tooltip.style.top = (e.clientY + 10) + 'px';
                                tooltip.innerHTML = `S${panel.stringId} (${panel.stringType}) | P${panel.panelNum}`;
                                tooltipShown = true;
                            }
                        } else {
                            cursor = 'pointer'; 
                        }
                        break; 
                    }
                }
                canvas.style.cursor = cursor;
                if (!tooltipShown) document.getElementById('tooltip').style.display = 'none';
            } else {
                canvas.style.cursor = 'grab';
            }
        });

        window.addEventListener('mouseup', () => {
            if (isAnchorDrag || activeGroupDrag) {
                saveToLocal();
            }
            dragTarget = null;
            isAnchorDrag = false;
            activeGroupDrag = null;
            view.isDragging = false;
        });

        // Save / Load logic (same as previous)
        function saveConfig() {
            const exportData = { ...state, tables: Array.from(state.tables.entries()), selectedId: null };
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(exportData, null, 2));
            const node = document.createElement('a'); node.setAttribute("href", dataStr); node.setAttribute("download", "solar_layout.json");
            document.body.appendChild(node); node.click(); node.remove();
        }
        function loadConfig(input) {
            const file = input.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);
                    state.nextId = imported.nextId || 100;
                    state.stringTypes = imported.stringTypes || []; 
                    state.inverters = imported.inverters || 10;
                    state.selectedId = null; 
                    state.tables = new Map(imported.tables);
                    document.getElementById('inp_inverters').value = state.inverters;
                    document.getElementById('inp_mppts').value = state.mpptCount || 2;
                    document.getElementById('inp_spm').value = state.stringsPerMppt || 2;
                    document.getElementById('chk_cross_group').checked = state.allowCrossGroup;
                    renderUI(); autoFitView();
                    saveToLocal();
                } catch (err) { alert("Error loading JSON: " + err); }
            }; reader.readAsText(file); input.value = '';
        }

        function clearAll() {
            if(confirm('Are you sure you want to clear all arrays?')) {
                state.tables.clear();
                state.selectedId = null;
                renderUI();
                draw();
                calculateMaterials();
                saveToLocal();
            }
        }

        init();

        function generateMaterialSummary(tablesList) {
        const maxP = parseInt(document.getElementById('mat_ppr').value) || 4;
        const rpp = parseInt(document.getElementById('mat_rpp').value) || 2; 
        const lpr = parseInt(document.getElementById('mat_lpr').value) || 2;

        let totE = 0, totM = 0, totC = 0, totR = 0, totL = 0;
        let html = '<table style="width:100%;font-size:13px;border-collapse:collapse; text-align:center;">' + 
                   '<tr style="background:#eee;text-align:center;height:30px;"><th style="text-align:left;padding-left:5px;">Array</th><th>Rails (Qty)</th><th>L-Feet</th><th>Ends</th><th>Mids</th><th>Conn</th></tr>';

        tablesList.forEach((t) => {
            if (!t.mask) return;
            const dir = t.railDir || 'row';

            let tE = 0, tM = 0, tC = 0, tR = 0;
            let segs = [];

            if (dir === 'row') {
                for (let r = 0; r < t.mask.length; r++) {
                    let len = 0;
                    for (let c = 0; c < t.mask[r].length; c++) {
                        if (t.mask[r][c] === 1) len++;
                        else if (len > 0) { segs.push(len); len = 0; }
                    }
                    if (len > 0) segs.push(len);
                }
            } else {
                const rows = t.mask.length;
                const cols = t.mask[0].length;
                for (let c = 0; c < cols; c++) {
                    let len = 0;
                    for (let r = 0; r < rows; r++) {
                        if (t.mask[r][c] === 1) len++;
                        else if (len > 0) { segs.push(len); len = 0; }
                    }
                    if (len > 0) segs.push(len);
                }
            }

            segs.forEach(l => {
                // Sum exact rail usage (e.g. 1.25 lengths * 2 rails = 2.5 rails)
                const railsForSeg = (l / maxP) * rpp;
                tR += railsForSeg;

                tE += 2 * rpp;
                if (l > 1) tM += (l - 1) * rpp;

                // Connectors are based on physical joins, so we still consider ceiling for splice count
                const nRailsInLine = Math.ceil(l / maxP);
                if (nRailsInLine > 1) tC += (nRailsInLine - 1) * rpp;
            });

            tR = Math.ceil(tR); // Round up final rail count for purchasing
            const tL = tR * lpr;

            totE += tE; totM += tM; totC += tC; totR += tR; totL += tL;
            html += `<tr style="border-bottom:1px solid #eee; height:25px;">
                        <td style="text-align:left;padding-left:5px;">${t.name}</td>
                        <td>${tR}</td>
                        <td>${tL}</td>
                        <td>${tE}</td>
                        <td>${tM}</td>
                        <td>${tC}</td>
                     </tr>`;
        });

        html += `<tr style="font-weight:bold;border-top:2px solid #ccc;background:#f9f9f9; height:35px;">
                    <td style="text-align:left;padding-left:5px;">TOTAL</td>
                    <td>${totR}</td>
                    <td>${totL}</td>
                    <td>${totE}</td>
                    <td>${totM}</td>
                    <td>${totC}</td>
                 </tr></table>`;
        return html;
    }

        function calculateMaterials() {
            // UI Update version uses all tables
            const html = generateMaterialSummary(Array.from(state.tables.values()));
            const container = document.getElementById('material_summary_content');
            if(container) container.innerHTML = html;
        }

        function showMaterialModal() {
            calculateMaterials();
            document.getElementById('mat_modal').style.display = 'flex';
        }
        function closeMatModal() {
            document.getElementById('mat_modal').style.display = 'none';
        }

        // --- SIDEBAR LOGIC ---
        let activePanelId = null;

        function togglePanel(panelName) {
            const drawer = document.getElementById('main_drawer');
            const targetId = 'panel_' + panelName;
            const targetContent = document.getElementById(targetId);
            const btn = document.getElementById('btn_' + panelName);

            document.querySelectorAll('.sidebar-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.panel-content').forEach(p => p.classList.remove('active'));

            if (activePanelId === targetId) {
                drawer.classList.remove('open');
                activePanelId = null;
            } else {
                drawer.classList.add('open');
                targetContent.classList.add('active');
                btn.classList.add('active');
                activePanelId = targetId;
            }
        }

        // --- PRINT LOGIC ---
        function openPrintModal() {
            const container = document.getElementById('print_list_container');
            container.innerHTML = '';
            
            const arrays = Array.from(state.tables.values()).sort((a,b) => {
                 if(a.group !== b.group) return a.group.localeCompare(b.group);
                 return a.name.localeCompare(b.name);
            });

            let lastGroup = null;
            arrays.forEach(t => {
                if (t.group !== lastGroup) {
                    const grp = document.createElement('div');
                    grp.className = 'print-group-header';
                    grp.innerText = t.group;
                    container.appendChild(grp);
                    lastGroup = t.group;
                }
                const item = document.createElement('div');
                item.className = 'print-item';
                item.innerHTML = `<input type="checkbox" id="pchk_${t.id}" value="${t.id}" checked> <label for="pchk_${t.id}">${t.name}</label>`;
                container.appendChild(item);
            });

            document.getElementById('print_modal').style.display = 'flex';
        }

        function togglePrintChecks(checked) {
            document.querySelectorAll('#print_list_container input[type="checkbox"]').forEach(c => c.checked = checked);
        }

        function confirmPrint() {
            const checkboxes = document.querySelectorAll('#print_list_container input[type="checkbox"]:checked');
            if (checkboxes.length === 0) { alert("Please select at least one array."); return; }
            
            const ids = Array.from(checkboxes).map(c => parseInt(c.value));
            document.getElementById('print_modal').style.display = 'none';
            printLayout(ids);
        }

        function drawTableToContext(ctx, table, offsetX, offsetY) {
        // Draw Name
        ctx.fillStyle = '#333';
        ctx.font = 'bold 16px sans-serif';
        ctx.textAlign = 'left';
        const dirLabel = table.slopeDir ? `(${table.slopeDir})` : '(S)';
        ctx.fillText(`${table.name} ${dirLabel}`, offsetX, offsetY - 10);

        // Draw Panels
        const pOffsetX = 0; 
        const pOffsetY = 0; 

        const isVert = table.railDir === 'col';
        const pW = isVert ? DRAW_OPTS.panelHeight : DRAW_OPTS.panelWidth;
        const pH = isVert ? DRAW_OPTS.panelWidth : DRAW_OPTS.panelHeight;

        let connectionPoints = {};

        table.grid.forEach((row, rIndex) => {
            row.forEach((panel, cIndex) => {
                const x = offsetX + pOffsetX + (cIndex * (pW + DRAW_OPTS.gapX));
                const y = offsetY + pOffsetY + (rIndex * (pH + DRAW_OPTS.gapY));
                const isMaskActive = table.mask[rIndex] && table.mask[rIndex][cIndex] === 1;

                if (panel) {
                    // Fill
                    ctx.fillStyle = panel.lightColor; 
                    ctx.fillRect(x, y, pW, pH);
                    // Stroke
                    ctx.strokeStyle = panel.color; 
                    ctx.lineWidth = 2; 
                    ctx.strokeRect(x, y, pW, pH);
                    // Text
                    ctx.fillStyle = '#000'; ctx.textAlign = 'center'; ctx.font = '9px sans-serif';
                    ctx.fillText(`S${panel.stringId}`, x + pW/2, y + pH/2 - 4);
                    ctx.font = 'bold 9px sans-serif'; 
                    ctx.fillText(panel.panelNum, x + pW/2, y + pH/2 + 7);

                    if(!connectionPoints[panel.stringId]) connectionPoints[panel.stringId] = [];
                    connectionPoints[panel.stringId].push({ x: x + pW/2, y: y + pH/2, num: panel.panelNum, color: panel.color });
                } else if (!isMaskActive) {
                    ctx.fillStyle = '#f9fafb'; ctx.fillRect(x, y, pW, pH);
                    ctx.strokeStyle = '#eee'; ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]); ctx.strokeRect(x, y, pW, pH); ctx.setLineDash([]);
                } else {
                    ctx.fillStyle = '#fff'; ctx.fillRect(x, y, pW, pH);
                    ctx.strokeStyle = '#ddd'; ctx.lineWidth = 1; ctx.strokeRect(x, y, pW, pH);
                }
            });
        });

            // Draw Wires (Overlay)
            for (let sId in connectionPoints) {
                const points = connectionPoints[sId]; points.sort((a, b) => a.num - b.num);
                if(points.length > 1) {
                    ctx.beginPath(); ctx.strokeStyle = points[0].color; ctx.lineWidth = 3; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                    ctx.moveTo(points[0].x, points[0].y);
                    for(let i=1; i<points.length; i++) {
                        if(points[i].num === points[i-1].num + 1) ctx.lineTo(points[i].x, points[i].y);
                        else ctx.moveTo(points[i].x, points[i].y);
                    }
                    ctx.stroke();
                }
                points.forEach(p => {
                    ctx.beginPath(); ctx.fillStyle = '#fff'; ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = '#333'; ctx.lineWidth = 1; ctx.stroke();
                });
            }
        }

        function printLayout(selectedIds) {
        const fullData = generateData(); 
        const idSet = new Set(selectedIds);
        const filteredTables = fullData.tables.filter(t => idSet.has(t.id));

        // Group by Group Name
        const groups = {};
        filteredTables.forEach(t => {
            if(!groups[t.group]) groups[t.group] = [];
            groups[t.group].push(t);
        });

        const snapshots = [];
        const PAGE_WIDTH = 1100;
        const PADDING = 40;

        for (let grpName in groups) {
            const groupTables = groups[grpName];

            let curX = PADDING, curY = PADDING, rowH = 0, maxW = 0;

            groupTables.forEach(t => {
                const isVert = t.railDir === 'col';
                const pW = isVert ? DRAW_OPTS.panelHeight : DRAW_OPTS.panelWidth;
                const pH = isVert ? DRAW_OPTS.panelWidth : DRAW_OPTS.panelHeight;

                const w = (t.bounds.cols * (pW + DRAW_OPTS.gapX));
                const h = (t.bounds.rows * (pH + DRAW_OPTS.gapY)) + 30;

                if (curX + w > PAGE_WIDTH && curX > PADDING) { 
                    curX = PADDING; curY += rowH + 50; rowH = 0;
                }
                t.printX = curX; t.printY = curY;
                curX += w + 40; rowH = Math.max(rowH, h); maxW = Math.max(maxW, curX);
            });

            const totalH = curY + rowH + PADDING;
            const totalW = Math.max(maxW, PAGE_WIDTH * 0.5);

            const tCanvas = document.createElement('canvas');
            const scale = 2; 
            tCanvas.width = totalW * scale; tCanvas.height = totalH * scale;
            const ctx = tCanvas.getContext('2d');
            ctx.scale(scale, scale); ctx.fillStyle = '#ffffff'; ctx.fillRect(0, 0, totalW, totalH);

            groupTables.forEach(t => {
                drawTableToContext(ctx, t, t.printX, t.printY + 25);
            });

            snapshots.push({ title: grpName, img: tCanvas.toDataURL('image/png') });
        }

        const selectedConfigTables = selectedIds.map(id => state.tables.get(id)).filter(t => t);
        const matContent = generateMaterialSummary(selectedConfigTables);

        // --- Generate Inverter Schedule ---
        let invContent = '<table style="width:100%; border-collapse:collapse; font-size:11px;"><thead><tr style="background:#f3f4f6;"><th style="border:1px solid #ddd; padding:6px; text-align:left;">Inverter</th><th style="border:1px solid #ddd; padding:6px;">MPPT</th><th style="border:1px solid #ddd; padding:6px;">Orientation</th><th style="border:1px solid #ddd; padding:6px; text-align:left;">Strings Assigned</th></tr></thead><tbody>';

        fullData.inverters.forEach(inv => {
            const usedMppts = inv.mppts.filter(m => m.strings.length > 0);
            if (usedMppts.length === 0) return;

            usedMppts.forEach((m, idx) => {
                invContent += '<tr>';
                if(idx === 0) {
                    invContent += `<td rowspan="${usedMppts.length}" style="border:1px solid #ddd; padding:6px; vertical-align:top; background:#fff; font-weight:bold;">Inv ${inv.id} <div style="font-weight:normal;color:#666;font-size:10px;">${inv.totalPanels} Panels</div></td>`;
                }
                invContent += `<td style="border:1px solid #ddd; padding:6px; text-align:center;">${m.id}</td>`;
                invContent += `<td style="border:1px solid #ddd; padding:6px; text-align:center;">${m.dir || '-'}</td>`;

                const strTags = m.strings.map(s => 
                    `<span style="display:inline-flex; align-items:center; border:1px solid #ddd; background:#fafafa; padding:2px 6px; margin:2px; border-radius:10px;"><span style="display:block; width:8px; height:8px; background:${s.color}; border-radius:50%; margin-right:4px;"></span><b>S${s.id}</b>&nbsp;<span style="color:#666; font-size:10px;">(${s.type})</span></span>`
                ).join(' ');
                invContent += `<td style="border:1px solid #ddd; padding:6px;">${strTags}</td></tr>`;
            });
        });
        invContent += '</tbody></table>';


        const win = window.open('', '_blank');
        let htmlContent = `
            <!DOCTYPE html>
            <html><head><title>Solar Layout Report</title><style>
                body { font-family: 'Segoe UI', sans-serif; padding: 20px; color: #333; -webkit-print-color-adjust: exact; }
                h1 { border-bottom: 2px solid #333; padding-bottom: 10px; }
                .meta { font-size: 12px; color: #666; margin-bottom: 30px; }
                .print-section { margin-bottom: 40px; page-break-inside: avoid; break-inside: avoid; border: 1px solid transparent; }
                .section-header { background: #f0f2f5; padding: 8px; font-size: 14px; border-left: 4px solid #3b82f6; margin-bottom: 10px; page-break-after: avoid; break-after: avoid; }
                .img-container { text-align: center; border: 1px solid #eee; padding: 10px; background: #fff; }
                img { max-width: 100%; height: auto; max-height: 95vh; }
                table { width: 100%; border-collapse: collapse; font-size: 11px; }
                th, td { border: 1px solid #ddd; padding: 6px; text-align: center; }
                th { background: #f9f9f9; }
                td:first-child { text-align: left; }
                @media print { body { padding: 0; margin: 10mm; } .force-break { page-break-before: always; } }
            </style></head><body>
                <h1>Solar Layout Report</h1>
                <div class="meta">Generated: ${new Date().toLocaleString()}</div>

                <div class="print-section">
                    <h2>Material Estimates</h2>
                    ${matContent}
                </div>

                <div class="print-section">
                    <h2>Inverter Schedule</h2>
                    ${invContent}
                </div>

                <div class="force-break"></div> `;

        snapshots.forEach(shot => {
            htmlContent += `
                <div class="print-section">
                    <div class="section-header">${shot.title}</div>
                    <div class="img-container"><img src="${shot.img}"></div>
                </div>`;
        });
        htmlContent += `</body></html>`;

        win.document.write(htmlContent); win.document.close(); win.focus();
        setTimeout(() => { win.print(); win.close(); }, 500);
    }
        function autoConfigStrings() {
            const msg = document.getElementById('auto_str_msg');
            msg.textContent = "Calculating best string configuration...";
            msg.style.color = "#d97706";

            setTimeout(() => {
                // 1. Count Total Panels on Map
                let totalPanels = 0;
                state.tables.forEach(t => {
                    if (t.mask) t.mask.forEach(r => r.forEach(c => totalPanels += c));
                });

                if (totalPanels === 0) {
                    msg.textContent = "Place panels on the map first.";
                    return;
                }

                // 2. Get Constraints
                const minLen = parseInt(document.getElementById('inp_str_min').value) || 8;
                const maxLen = parseInt(document.getElementById('inp_str_max').value) || 13;
                const maxStrings = state.inverters * state.mpptCount * state.stringsPerMppt;

                // 3. Iterate Valid Counts
                // Min strings needed = ceil(total / maxLen)
                // Max strings possible = floor(total / minLen)
                const startCount = Math.ceil(totalPanels / maxLen);
                const endCount = Math.floor(totalPanels / minLen);

                let bestConfig = null;
                let minMetric = Infinity;

                // Debug info
                console.log(`AutoString: Panels=${totalPanels}, Range=[${startCount}, ${endCount}], Limit=${maxStrings}`);

                for (let count = startCount; count <= endCount; count++) {
                    if (count > maxStrings) continue;

                    // Generate Balanced Set for this Count
                    // e.g. 50 panels, 4 strings => Base 12, Remainder 2 => Two 13s, Two 12s
                    const baseSize = Math.floor(totalPanels / count);
                    const remainder = totalPanels % count;
                    
                    const types = [];
                    // We have 'remainder' strings of size (baseSize + 1)
                    if (remainder > 0) types.push({ count: remainder, size: baseSize + 1 });
                    // We have 'count - remainder' strings of size baseSize
                    if (count - remainder > 0) types.push({ count: count - remainder, size: baseSize });

                    // Quick Simulation to test Layout Fit
                    // We interpret this temporary config into a flat permutation
                    let tempStrings = [];
                    types.forEach(t => { for(let k=0; k<t.count; k++) tempStrings.push({ size: t.size, type: `${t.size}p` }); });
                    
                    // Add Excess Gaps if needed (though we matched totalPanels exactly, gaps might occur if logic changes, strictly here we matched sum)
                    // Actually, runOptimization logic handles gaps if sum != total slots.
                    // Here sum == totalPanels. But TotalSlots might be > TotalPanels.
                    // The metric calculation handles gaps fine.

                    // Try a few shuffles for this configuration to see if it *can* fit well
                    const iterations = 20; 
                    for(let i=0; i<iterations; i++) {
                        // Shuffle tempStrings indices
                        const perm = Array.from({length: tempStrings.length}, (_, k) => k);
                        for (let k = perm.length - 1; k > 0; k--) {
                            const j = Math.floor(Math.random() * (k + 1));
                            [perm[k], perm[j]] = [perm[j], perm[k]];
                        }

                        // Temporarily Mock State
                        const savedTypes = state.stringTypes;
                        const savedPerm = state.stringPermutation;
                        
                        // We need to inject this into generateData. 
                        // Instead of overwriting global state heavily, let's just mock the 'stringPermutation' logic behavior
                        // But generateData reads state.stringTypes.
                        
                        state.stringTypes = types;
                        state.stringPermutation = perm; // This perm is 0..count-1. 
                        
                        // We need to handle the case where generateData expects specific format.
                        // state.stringTypes is [{count, size}].
                        // state.stringPermutation is indices into the expanded string list.
                        
                        const data = generateData();
                        const stats = calculateMetric(data.tables);
                        
                        // Composite Score: Splits * 1000 + SumSq
                        // We prioritize zero splits heavily.
                        const score = (stats.splits * 10000) + stats.sumSq;

                        if (score < minMetric) {
                            minMetric = score;
                            bestConfig = { types: JSON.parse(JSON.stringify(types)), perm: perm, metric: score };
                        }

                        // Restore
                        state.stringTypes = savedTypes;
                        state.stringPermutation = savedPerm;
                    }
                }

                if (bestConfig) {
                    state.stringTypes = bestConfig.types;
                    state.stringPermutation = bestConfig.perm;
                    msg.innerHTML = `Found Config: <b style="color:#10b981">${bestConfig.types.map(t=>`${t.count}x${t.size}`).join(', ')}</b> (Score: ${Math.round(bestConfig.metric)})`;
                    renderStringList();
                    draw();
                    saveToLocal();
                } else {
                    msg.textContent = "No valid configuration found within limits.";
                    msg.style.color = "#ef4444";
                }
            }, 50);
        }
        function runOptimization() {
            const resultDiv = document.getElementById('opt_result');
            resultDiv.textContent = "Optimizing string order...";
            resultDiv.style.color = "#d97706";
            
            setTimeout(() => {
                let totalPanels = 0;
                let totalSlots = 0;
                
                state.stringTypes.forEach(t => totalPanels += (t.count * t.size));
                state.tables.forEach(t => {
                    if (t.mask) t.mask.forEach(r => r.forEach(c => totalSlots += c));
                });

                const totalStringGroups = state.stringTypes.reduce((acc, t) => acc + t.count, 0);
                const excess = Math.max(0, totalSlots - totalPanels);
                const totalItems = totalStringGroups + excess;
                
                if (totalItems === 0) { resultDiv.textContent = "Nothing to optimize."; return; }
                
                let bestPerm = null;
                let minSumSq = Infinity;
                let bestSplitCount = Infinity;
                
                const iterations = 500;
                
                for(let i=0; i<iterations; i++) {
                    const perm = Array.from({length: totalItems}, (_, k) => k);
                    // Fisher-Yates shuffle
                    for (let k = perm.length - 1; k > 0; k--) {
                        const j = Math.floor(Math.random() * (k + 1));
                        [perm[k], perm[j]] = [perm[j], perm[k]];
                    }
                    
                    state.stringPermutation = perm;
                    const data = generateData();
                    const stats = calculateMetric(data.tables);
                    
                    if (stats.sumSq < minSumSq) {
                        minSumSq = stats.sumSq;
                        bestSplitCount = stats.splits;
                        bestPerm = [...perm];
                    }
                }
                
                state.stringPermutation = bestPerm;
                generateData(); 
                
                resultDiv.innerHTML = `<b>Optimization Complete.</b><br>Splits: ${bestSplitCount} | SumSq Metric: ${Math.round(minSumSq)}`;
                resultDiv.style.color = "#10b981";
                draw();
                saveToLocal();
            }, 50);
        }
        
        function calculateMetric(tables) {
            let splits = 0;
            let sumSq = 0;
            
            const panels = [];
            tables.forEach(t => {
                if(t._assignedPanels && t.grid) {
                    t._assignedPanels.forEach(p => {
                        // Ignore Gaps in scoring
                        if (p.isGap) return;

                        let r = -1, c = -1;
                        for(let rr=0; rr<t.grid.length; rr++) {
                            for(let cc=0; cc<t.grid[0].length; cc++) {
                                if(t.grid[rr][cc] === p) { r=rr; c=cc; break; }
                            }
                            if(r!==-1) break;
                        }

                        if(r !== -1) {
                             const pOffsetX = 5; const pOffsetY = 20;
                             const isVert = t.railDir === 'col';
                             const pW = isVert ? DRAW_OPTS.panelHeight : DRAW_OPTS.panelWidth;
                             const pH = isVert ? DRAW_OPTS.panelWidth : DRAW_OPTS.panelHeight;
                             
                             const lx = pOffsetX + c * (pW + DRAW_OPTS.gapX) + pW/2;
                             const ly = pOffsetY + r * (pH + DRAW_OPTS.gapY) + pH/2;
                             const rotRad = (t.layout.rot || 0) * Math.PI / 180;
                             const cx = t.layout.w / 2; const cy = t.layout.h / 2;
                             const dx = lx - cx; const dy = ly - cy;
                             const wx = dx * Math.cos(rotRad) - dy * Math.sin(rotRad);
                             const wy = dx * Math.sin(rotRad) + dy * Math.cos(rotRad);
                             
                             panels.push({
                                 strId: p.stringId,
                                 pNum: p.panelNum,
                                 tId: t.id,
                                 x: t.layout.x + cx + wx,
                                 y: t.layout.y + cy + wy
                             });
                        }
                    });
                }
            });

            const strings = {};
            panels.forEach(p => {
                if(!strings[p.strId]) strings[p.strId] = [];
                strings[p.strId].push(p);
            });

            for(let sId in strings) {
                const arr = strings[sId];
                arr.sort((a,b) => a.pNum - b.pNum);
                
                for(let i=0; i<arr.length-1; i++) {
                    const p1 = arr[i];
                    const p2 = arr[i+1];
                    
                    if (p1.tId !== p2.tId) {
                        splits++;
                        const setA = arr.filter(p => p.tId === p1.tId);
                        const setB = arr.filter(p => p.tId === p2.tId);
                        
                        let minD2 = Infinity;
                        for(let a of setA) {
                            for(let b of setB) {
                                const dx = a.x - b.x;
                                const dy = a.y - b.y;
                                const d2 = dx*dx + dy*dy;
                                if(d2 < minD2) minD2 = d2;
                            }
                        }
                        if (minD2 !== Infinity) sumSq += minD2;
                    }
                }
            }
            return { splits, sumSq };
        }
    </script>
</body>
</html>